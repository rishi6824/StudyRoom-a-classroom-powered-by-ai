{% extends "core/base_interview.html" %}
{% load static %}

{% block title %}Interview Room - Question {{ question_num }}{% endblock %}
{% block body_class %}interview-mode{% endblock %}

{% block content %}
<div class="interview-room">
    <div class="container">
        <!-- OTP Verification Modal - Show before camera/mic access -->
        <!-- Permission Warning - Hidden by default, can be shown if needed -->
        <div id="permissionWarning" class="permission-warning" style="display: none;">
            <div class="warning-content">
                <h4>üé• Camera & Microphone Optional</h4>
                <p>The interview will proceed with robot animation. Camera access is optional for enhanced experience.
                </p>
                <div class="permission-steps">
                    <p><strong>Interview starting automatically...</strong></p>
                    <div class="loading-spinner" style="text-align: center; margin: 1rem 0;">
                        <div
                            style="display: inline-block; width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite;">
                        </div>
                        <p style="margin-top: 1rem; color: #667eea;">ü§ñ Initializing Rishi...</p>
                    </div>
                </div>
                <button id="requestPermissions" class="btn btn-primary btn-large">
                    üé§ Enable Camera & Microphone (Optional)
                </button>
                <div id="permissionHelp" class="permission-help" style="display: none; margin-top: 1rem;">
                    <p><strong>Having issues?</strong></p>
                    <ul>
                        <li>Make sure you're using <strong>HTTPS</strong></li>
                        <li>Check for camera/microphone icons in address bar</li>
                        <li>Refresh the page and try again</li>
                    </ul>
                    <button id="testRobotButton" class="btn btn-secondary" style="margin-top: 1rem;"
                        onclick="showRobotForTesting()">
                        ü§ñ Test Robot Animation (Skip Camera)
                    </button>
                </div>
            </div>
        </div>

        <!-- OTP Verification Modal (dev-friendly) -->
        <div id="otpModal" class="otp-modal" style="display: none;">
            <div class="otp-modal-content">
                <h3>üîê Verify OTP to Start</h3>
                <p>Enter the 6-digit OTP shown below to verify your session and enable camera/microphone.</p>
                <div class="otp-display">
                    <div><strong>OTP:</strong> <span id="otpCodeDisplay">{{ session.get('interview_otp', 'N/A')
                            }}</span></div>
                    <div style="font-size: 0.9rem; color: #7f8c8d; margin-top: .5rem;">(This is shown for local/dev
                        convenience)</div>
                </div>
                <div class="otp-input-group">
                    <input id="otpInput" class="otp-input" type="text" maxlength="6" placeholder="Enter OTP" />
                </div>
                <div style="display:flex; gap:8px; justify-content:center; margin-top: 1rem;">
                    <button id="verifyOtpBtn" class="btn btn-primary">Verify OTP</button>
                    <button id="autoVerifyBtn" class="btn btn-secondary">Auto-verify (dev)</button>
                </div>
                <div id="otpError" class="otp-error" style="display: none; margin-top: 1rem;">Invalid OTP.</div>
                <div style="margin-top: 1rem; font-size: 0.9rem; color: #7f8c8d;">If you don't see an OTP, try reloading
                    the page or check server logs for the generated OTP.</div>
            </div>
        </div>
    </div>

    <script>
        // GLOBAL ERROR HANDLER - Catches startup errors
        window.onerror = function (msg, url, line, col, error) {
            console.error('üî• Global Error:', msg, url, line, error);
            const errDiv = document.createElement('div');
            errDiv.style.position = 'fixed';
            errDiv.style.top = '0';
            errDiv.style.left = '0';
            errDiv.style.width = '100%';
            errDiv.style.background = '#ffcccc';
            errDiv.style.color = '#cc0000';
            errDiv.style.padding = '10px';
            errDiv.style.zIndex = '10000';
            errDiv.style.borderBottom = '2px solid #cc0000';
            errDiv.innerHTML = '<strong>System Error:</strong> ' + msg + ' <button onclick="this.parentNode.remove()">Dismiss</button>';
            document.body.appendChild(errDiv);

            // Failsafe: Force UI to show
            document.body.classList.add('loaded');
            const robot = document.getElementById('robotAnimation');
            const placeholder = document.getElementById('cameraPlaceholder');
            if (robot && placeholder) {
                if (robot.style.display === 'none' && placeholder.style.display === 'none') {
                    placeholder.style.display = 'flex'; // Restore placeholder
                    placeholder.innerHTML = '<div style="text-align:center; color:red;"><h3>System Error</h3><p>Please refresh the page.</p></div>';
                }
            }
            return false;
        };

        // UI FAILSAFE: Ensure content is visible after 3 seconds even if JS hangs
        setTimeout(function () {
            if (document.body.style.display === 'none' || document.body.style.opacity === '0') {
                console.warn('‚ö†Ô∏è Failsafe triggered: Forcing body visibility');
                document.body.style.display = 'block';
                document.body.style.opacity = '1';
            }
            // Ensure loading overlay is gone
            const overlay = document.getElementById('loadingOverlay');
            if (overlay && overlay.style.display !== 'none') {
                // If it's been 5 seconds and overlay is still there, hide it
                console.warn('‚ö†Ô∏è Failsafe triggered: Hiding stuck loading overlay');
                overlay.style.display = 'none';
            }
        }, 5000);
    </script>

    <script>
        // On page load, if the server-side session already marked OTP verified, set client flag
        try {
            const serverOtpVerified = "{{ 'true' if session.get('otp_verified') else 'false' }}" === "true";
            if (serverOtpVerified) {
                sessionStorage.setItem('otpVerified', 'true');
            }
        } catch (e) { /* ignore if templating not possible */ }

        // Show OTP modal when necessary
        function showOtpModal() {
            const otpModal = document.getElementById('otpModal');
            if (otpModal) otpModal.style.display = 'flex';
        }

        // OTP verification logic (helper functions only, no overrides)
        document.addEventListener('DOMContentLoaded', function () {
            const verifyBtn = document.getElementById('verifyOtpBtn');
            if (verifyBtn) {
                verifyBtn.addEventListener('click', async function () {
                    const code = document.getElementById('otpInput').value.trim();
                    const err = document.getElementById('otpError');
                    if (err) err.style.display = 'none';
                    if (!code || code.length < 6) {
                        if (err) {
                            err.textContent = 'Please enter the 6-digit code';
                            err.style.display = 'block';
                        }
                        return;
                    }

                    try {
                        const resp = await fetch('/api/verify_otp', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ otp: code })
                        });
                        const data = await resp.json();
                        if (resp.ok && data.success) {
                            sessionStorage.setItem('otpVerified', 'true');
                            const otpModal = document.getElementById('otpModal');
                            if (otpModal) otpModal.style.display = 'none';
                            // Trigger permissions flow now that OTP is verified
                            // Use window.interviewManager if available
                            if (window.interviewManager) window.interviewManager.requestPermissions();
                        } else {
                            if (err) {
                                err.textContent = data.error || 'OTP verification failed';
                                err.style.display = 'block';
                            }
                        }
                    } catch (e) {
                        if (err) {
                            err.textContent = 'Verification error';
                            err.style.display = 'block';
                        }
                    }
                });
            }

            const autoVerifyBtn = document.getElementById('autoVerifyBtn');
            if (autoVerifyBtn) {
                autoVerifyBtn.addEventListener('click', async function () {
                    try {
                        const codeDisplay = document.getElementById('otpCodeDisplay');
                        const code = codeDisplay ? codeDisplay.textContent.trim() : '000000';

                        const resp = await fetch('/api/verify_otp', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ otp: code })
                        });
                        const data = await resp.json();
                        if (resp.ok && data.success) {
                            sessionStorage.setItem('otpVerified', 'true');
                            const otpModal = document.getElementById('otpModal');
                            if (otpModal) otpModal.style.display = 'none';
                            if (window.interviewManager) window.interviewManager.requestPermissions();
                        } else {
                            alert('Auto-verify failed');
                        }
                    } catch (e) {
                        console.error(e);
                    }
                });
            }
        });
    </script>

    <div class="interview-header">
        <h2>Rishi Interview Session</h2>
        <div class="progress-info">
            Question {{ question_num }} of {{ total_questions }}
            <div class="timer-container">
                <div class="timer-section">
                    <span class="timer-label">Answer Time:</span>
                    <div class="timer" id="answerTimer">30</div>
                </div>
            </div>
        </div>
        <!-- Manual start button for debugging -->
        <div style="margin-top: 1rem; text-align: center;">
            <button id="manualStartBtn" class="btn btn-primary" style="background: #28a745; display: none;"
                onclick="showRobotForTesting()">
                üöÄ Start Interview Manually
            </button>
        </div>
    </div>

    <div class="interview-content">
        <!-- Video Feed -->
        <div class="video-section">
            <div class="video-container">
                <video id="interviewVideo" autoplay muted playsinline style="display: none;"></video>
                <!-- Robot Animation - Shows instead of camera feed -->
                <div id="robotAnimation" class="robot-animation" style="display: none;">
                    <div class="robot-container">
                        <div class="robot-head">
                            <div class="robot-eyes">
                                <div class="robot-eye left-eye"></div>
                                <div class="robot-eye right-eye"></div>
                            </div>
                            <div class="robot-mouth"></div>
                        </div>
                        <div class="robot-body">
                            <div class="robot-chest">
                                <div class="robot-screen">
                                    <div class="screen-content">
                                        <div class="screen-text">RISHI</div>
                                        <div class="screen-pulse"></div>
                                        <!-- AI Avatar with pulsing effect -->
                                        <div class="ai-avatar">
                                            <div class="pulse-ring"></div>
                                            <div class="core"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="robot-arms">
                                <div class="robot-arm left-arm"></div>
                                <div class="robot-arm right-arm"></div>
                            </div>
                        </div>
                        <div class="robot-base">
                            <div class="robot-legs">
                                <div class="robot-leg left-leg"></div>
                                <div class="robot-leg right-leg"></div>
                            </div>
                        </div>
                    </div>
                    <div class="robot-glow"></div>
                </div>
                <div id="cameraPlaceholder" class="camera-placeholder">
                    <div class="placeholder-content">
                        <div class="placeholder-icon">ü§ñ</div>
                        <p>AI Interviewer will appear here</p>
                        <button id="enableCamera" class="btn btn-primary">Start Interview</button>
                    </div>
                </div>
                <div class="video-overlay">
                    <div class="status-indicator" id="statusIndicator">
                        <span class="status-dot"></span>
                        <span id="statusText">Click "Start Interview" to begin</span>
                    </div>
                    <!-- Physical Analysis Indicators with Animations -->
                    <div id="physicalAnalysisIndicator"
                        style="display: none; position: absolute; top: 50px; left: 15px; background: rgba(102, 126, 234, 0.95); backdrop-filter: blur(10px); color: white; padding: 15px 20px; border-radius: 25px; font-size: 13px; font-weight: 600; box-shadow: 0 8px 25px rgba(0,0,0,0.3); z-index: 100; min-width: 200px;">
                        <div
                            style="font-size: 14px; font-weight: 700; margin-bottom: 10px; text-align: center; border-bottom: 2px solid rgba(255,255,255,0.3); padding-bottom: 8px;">
                            üìä Live Analysis</div>
                        <div id="confidenceScore" class="analysis-item">
                            <span class="analysis-label">Confidence:</span>
                            <span class="analysis-value" id="confidenceValue">--</span>
                            <div class="analysis-bar">
                                <div class="analysis-bar-fill" id="confidenceBar" style="width: 0%;"></div>
                            </div>
                        </div>
                        <div id="voiceScore" class="analysis-item">
                            <span class="analysis-label">Voice:</span>
                            <span class="analysis-value" id="voiceValue">--</span>
                            <div class="analysis-bar">
                                <div class="analysis-bar-fill" id="voiceBar" style="width: 0%;"></div>
                            </div>
                        </div>
                        <div id="bodyLanguageScore" class="analysis-item">
                            <span class="analysis-label">Body Language:</span>
                            <span class="analysis-value" id="bodyLanguageValue">--</span>
                            <div class="analysis-bar">
                                <div class="analysis-bar-fill" id="bodyLanguageBar" style="width: 0%;"></div>
                            </div>
                        </div>
                        <div id="physicalScore" class="analysis-item"
                            style="margin-top: 10px; padding-top: 10px; border-top: 2px solid rgba(255,255,255,0.3); font-weight: 700;">
                            <span class="analysis-label">Overall Score:</span>
                            <span class="analysis-value" id="physicalScoreValue" style="font-size: 16px;">--</span>
                            <div class="analysis-bar">
                                <div class="analysis-bar-fill" id="physicalScoreBar"
                                    style="width: 0%; background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="ai-speaking-indicator" id="aiSpeakingIndicator">
                        <div class="ai-avatar">ü§ñ</div>
                        <div class="ai-speech-bubble" id="aiSpeechBubble">
                            <p id="aiQuestionText">{{ question.question|e if question else "Loading question..." }}
                            </p>
                        </div>
                    </div>
                    <div class="recording-indicator" id="recordingIndicator" style="display: none;">
                        <span class="recording-dot"></span>
                        You are Speaking
                    </div>
                </div>
            </div>
        </div>

        <!-- Question Section -->
        <div class="question-section">
            <!-- Chatbot Button - Shows answer section when clicked -->
            <div class="chatbot-button-container" id="chatbotButtonContainer" style="display: block;">
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button id="chatbotButton" class="btn btn-primary btn-large chatbot-btn">
                        üí¨ Open Chatbot to Respond
                    </button>
                    <!-- Skip button moved here to be always visible -->
                    <button type="button" id="skipButtonMain" class="btn btn-secondary btn-large">
                        ‚è≠Ô∏è Skip Question
                    </button>
                </div>
            </div>

            <!-- Answer Section - Hidden by default, shown when chatbot button is clicked -->
            <div class="answer-section" id="answerSection" style="display: none;">
                <div class="answer-section-header">
                    <h4>üí¨ Your Response</h4>
                    <button type="button" id="closeAnswerSection" class="btn btn-small btn-secondary">‚úï
                        Close</button>
                </div>
                <form id="answerForm">
                    <div class="form-group">
                        <label for="answer">Your Response:</label>
                        <textarea id="answer" name="answer" rows="6"
                            placeholder="Rishi has asked you a question. Please respond by typing or using voice..."
                            required></textarea>
                    </div>

                    <!-- Voice Input Section -->
                    <div class="voice-section">
                        <div class="voice-controls">
                            <button type="button" id="voiceButton" class="btn btn-voice">
                                üé§ Speak Your Answer
                            </button>
                            <button type="button" id="stopVoiceButton" class="btn btn-secondary" style="display: none;">
                                ‚èπÔ∏è Stop Speaking
                            </button>
                        </div>
                        <div id="voiceStatus" class="voice-status">
                            Click the microphone to speak your response
                        </div>
                        <div id="voicePreview" class="voice-preview"></div>

                        <!-- Audio Visualizer -->
                        <div class="audio-visualizer">
                            <canvas id="visualizer" width="300" height="50" style="display: none;"></canvas>
                        </div>
                    </div>

                    <div class="action-buttons">
                        <button type="submit" class="btn btn-primary">Submit Response</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Feedback Section -->
    <div id="feedbackSection" class="feedback-section" style="display: none;">
        <h4>Rishi Feedback:</h4>
        <div id="feedbackContent"></div>
        <div class="auto-next-countdown">
            Next question in: <span id="nextCountdown">5</span> seconds
        </div>
        <button id="nextQuestionBtn" class="btn btn-primary">Next Question Now</button>
    </div>
</div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="loading-spinner"></div>
    <p>Rishi is analyzing your response...</p>
</div>

<script src="{{ {% static 'core/js/voice-recognition.js' %}"></script>
<script>
    // Text-to-Speech Handler - Enhanced Version
    class TextToSpeech {
        constructor() {
            this.synthesis = window.speechSynthesis;
            this.isMuted = false;
            this.currentUtterance = null;
            this.selectedVoice = null;
            this.voicesLoaded = false;
            console.log('üéµ TTS initialized');

            // Load voices (may need to wait)
            this.loadVoices();

            // Some browsers load voices asynchronously
            if (this.synthesis.onvoiceschanged !== undefined) {
                this.synthesis.onvoiceschanged = () => {
                    this.loadVoices();
                };
            }
        }

        loadVoices() {
            const voices = this.synthesis.getVoices();
            console.log(`üì¢ Loaded ${voices.length} voices`);

            // Prefer high-quality English voices
            const preferredVoices = [
                'Google UK English Female',
                'Microsoft Zira - English (United States)',
                'Samantha',
                'Karen',
                'Alex',
                'Google US English'
            ];

            // Try to find preferred voice
            for (const preferredName of preferredVoices) {
                const voice = voices.find(v => v.name.includes(preferredName));
                if (voice && voice.lang.startsWith('en')) {
                    this.selectedVoice = voice;
                    console.log(`‚úÖ Selected voice: ${voice.name}`);
                    this.voicesLoaded = true;
                    return;
                }
            }

            // Fallback to any English voice
            const englishVoice = voices.find(voice =>
                voice.lang.startsWith('en') && voice.localService === true
            ) || voices.find(voice => voice.lang.startsWith('en'));

            if (englishVoice) {
                this.selectedVoice = englishVoice;
                console.log(`‚úÖ Selected fallback voice: ${englishVoice.name}`);
            }

            this.voicesLoaded = true;
        }

        speakQuestion(text) {
            return new Promise((resolve, reject) => {
                if (this.isMuted) {
                    console.log('üîá TTS muted, skipping speech');
                    resolve();
                    return;
                }

                // Wait for voices to load if not ready
                if (!this.voicesLoaded) {
                    setTimeout(() => {
                        this.speakQuestion(text).then(resolve).catch(reject);
                    }, 100);
                    return;
                }

                // Stop any current speech
                this.stop();

                // Clean text - remove extra spaces and format
                const cleanText = text.replace(/\s+/g, ' ').trim();

                // Create new utterance
                this.currentUtterance = new SpeechSynthesisUtterance(cleanText);

                // Configure voice with better settings
                if (this.selectedVoice) {
                    this.currentUtterance.voice = this.selectedVoice;
                }

                // Optimized speech settings for clarity
                this.currentUtterance.rate = 0.85;  // Slightly slower for clarity
                this.currentUtterance.pitch = 1.1;   // Slightly higher pitch (more pleasant)
                this.currentUtterance.volume = 1.0;  // Full volume
                this.currentUtterance.lang = 'en-US'; // Explicit language

                // Event handlers with better error handling
                this.currentUtterance.onstart = () => {
                    console.log('üó£Ô∏è TTS started speaking:', cleanText.substring(0, 50) + '...');
                    // Show speaking indicator
                    const indicator = document.getElementById('aiSpeakingIndicator');
                    if (indicator) {
                        indicator.style.display = 'flex';
                    }
                };

                this.currentUtterance.onend = () => {
                    console.log('‚úÖ TTS finished speaking');
                    this.currentUtterance = null;
                    // Hide speaking indicator
                    const indicator = document.getElementById('aiSpeakingIndicator');
                    if (indicator) {
                        // Keep visible for a moment
                        setTimeout(() => {
                            // Don't hide completely if we want to show the question text
                            // indicator.style.display = 'none'; 
                            // Instead just stop the animation effect if any
                            indicator.classList.remove('active-speaking');
                        }, 2000);
                    }
                    // Remove robot speaking animation
                    const robotAnimation = document.getElementById('robotAnimation');
                    if (robotAnimation) {
                        robotAnimation.classList.remove('robot-speaking');
                    }
                    resolve();
                };

                this.currentUtterance.onerror = (event) => {
                    console.error('‚ùå TTS error:', event.error, event);
                    this.currentUtterance = null;

                    // Try fallback: speak without voice selection
                    if (event.error !== 'interrupted') {
                        console.log('üîÑ Trying fallback TTS...');
                        const fallbackUtterance = new SpeechSynthesisUtterance(cleanText);
                        fallbackUtterance.rate = 0.85;
                        fallbackUtterance.pitch = 1.0;
                        fallbackUtterance.volume = 1.0;
                        fallbackUtterance.onend = () => resolve();
                        fallbackUtterance.onerror = () => {
                            console.error('‚ùå Fallback TTS also failed');
                            resolve(); // Resolve anyway to continue interview
                        };
                        this.synthesis.speak(fallbackUtterance);
                    } else {
                        resolve(); // Interrupted is not a real error
                    }
                };

                // Start speaking with a small delay to ensure synthesis is ready
                setTimeout(() => {
                    try {
                        // Check if synthesis is available
                        if (!this.synthesis) {
                            console.error('‚ùå Speech synthesis not available');
                            resolve();
                            return;
                        }

                        // Cancel any pending speech
                        if (this.synthesis.speaking) {
                            this.synthesis.cancel();
                            // Wait a bit before starting new speech
                            setTimeout(() => {
                                if (this.currentUtterance instanceof SpeechSynthesisUtterance) {
                                    this.synthesis.speak(this.currentUtterance);
                                    console.log('üó£Ô∏è TTS started speaking (after cancel)');
                                } else {
                                    console.error('‚ùå Invalid Utterance object (after cancel)');
                                    resolve();
                                }
                            }, 100);
                        } else {
                            if (this.currentUtterance instanceof SpeechSynthesisUtterance) {
                                this.synthesis.speak(this.currentUtterance);
                                console.log('üó£Ô∏è TTS started speaking');
                            } else {
                                console.error('‚ùå Invalid Utterance object');
                                resolve();
                            }
                        }
                    } catch (error) {
                        console.error('‚ùå Error starting TTS:', error);
                        resolve(); // Continue even if TTS fails
                    }
                }, 200); // Increased delay for better reliability
            });
        }

        stop() {
            if (this.synthesis.speaking) {
                this.synthesis.cancel();
                console.log('‚èπÔ∏è TTS stopped');
            }
            this.currentUtterance = null;
        }

        toggleMute() {
            this.isMuted = !this.isMuted;
            console.log('üîá TTS muted:', this.isMuted);
            if (this.isMuted) {
                this.stop();
            }
            return this.isMuted;
        }
    }

    // Physical Analysis Manager
    class PhysicalAnalysisManager {
        constructor() {
            this.videoFrames = [];
            this.audioSegments = [];
            this.frameInterval = null;
            this.audioInterval = null;
            this.canvas = null;
            this.ctx = null;
            this.audioContext = null;
            this.analyser = null;
            this.mediaStream = null;
            this.analysisInterval = 2000; // Analyze every 2 seconds
            this.isCollecting = false;
        }

        initialize(videoElement, mediaStream) {
            this.mediaStream = mediaStream;
            this.videoElement = videoElement;

            // Create canvas for video frame capture
            this.canvas = document.createElement('canvas');
            this.canvas.width = videoElement.videoWidth || 640;
            this.canvas.height = videoElement.videoHeight || 480;
            this.ctx = this.canvas.getContext('2d');

            // Setup audio analysis
            try {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.analyser = this.audioContext.createAnalyser();
                const audioTracks = mediaStream.getAudioTracks();
                if (audioTracks.length > 0) {
                    const source = this.audioContext.createMediaStreamSource(mediaStream);
                    source.connect(this.analyser);
                    this.analyser.fftSize = 256;
                }
            } catch (e) {
                console.warn('Audio context not available:', e);
            }

            console.log('‚úÖ Physical analysis manager initialized');
        }

        startCollecting() {
            if (this.isCollecting) return;

            this.isCollecting = true;
            this.videoFrames = [];
            this.audioSegments = [];

            // Capture video frames periodically
            this.frameInterval = setInterval(() => {
                this.captureVideoFrame();
            }, this.analysisInterval);

            // Capture audio segments periodically
            if (this.analyser) {
                this.audioInterval = setInterval(() => {
                    this.captureAudioSegment();
                }, this.analysisInterval);
            }

            console.log('üé• Started collecting physical analysis data');
        }

        stopCollecting() {
            this.isCollecting = false;

            if (this.frameInterval) {
                clearInterval(this.frameInterval);
                this.frameInterval = null;
            }

            if (this.audioInterval) {
                clearInterval(this.audioInterval);
                this.audioInterval = null;
            }

            console.log('üõë Stopped collecting physical analysis data');
        }

        captureVideoFrame() {
            if (!this.videoElement || !this.ctx) return;

            try {
                // Draw video frame to canvas
                this.canvas.width = this.videoElement.videoWidth || 640;
                this.canvas.height = this.videoElement.videoHeight || 480;
                this.ctx.drawImage(this.videoElement, 0, 0, this.canvas.width, this.canvas.height);

                // Convert canvas to base64
                const frameData = this.canvas.toDataURL('image/jpeg', 0.8).split(',')[1]; // Remove data:image/jpeg;base64, prefix

                // Send to server for analysis
                this.sendPhysicalData(frameData, null);

            } catch (e) {
                console.error('Error capturing video frame:', e);
            }
        }

        captureAudioSegment() {
            if (!this.analyser) return;

            try {
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                this.analyser.getByteFrequencyData(dataArray);

                // Convert audio data to base64
                const audioData = btoa(String.fromCharCode.apply(null, dataArray));

                // Send to server for analysis
                this.sendPhysicalData(null, audioData);

            } catch (e) {
                console.error('Error capturing audio segment:', e);
            }
        }

        async sendPhysicalData(videoFrame, audioSegment) {
            try {
                const formData = new FormData();
                if (videoFrame) {
                    formData.append('video_frame', videoFrame);
                }
                if (audioSegment) {
                    formData.append('audio_segment', audioSegment);
                }

                // Send to server for real-time analysis
                const response = await fetch('/update_physical_analysis', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.summary) {
                        // Update UI with physical analysis results
                        this.updatePhysicalAnalysisUI(data.summary);
                    }
                }
            } catch (e) {
                console.error('Error sending physical data:', e);
            }
        }

        updatePhysicalAnalysisUI(summary) {
            // Update UI elements with animated physical analysis scores
            const confidenceValue = document.getElementById('confidenceValue');
            const confidenceBar = document.getElementById('confidenceBar');
            const voiceValue = document.getElementById('voiceValue');
            const voiceBar = document.getElementById('voiceBar');
            const bodyLanguageValue = document.getElementById('bodyLanguageValue');
            const bodyLanguageBar = document.getElementById('bodyLanguageBar');
            const physicalScoreValue = document.getElementById('physicalScoreValue');
            const physicalScoreBar = document.getElementById('physicalScoreBar');

            // Animate confidence score
            if (confidenceValue && summary.confidence !== undefined) {
                const score = summary.confidence;
                confidenceValue.textContent = `${score.toFixed(1)}/10`;
                if (confidenceBar) {
                    confidenceBar.style.width = `${(score / 10) * 100}%`;
                    confidenceBar.style.transition = 'width 0.5s ease-out';
                }
                // Add pulse animation for high scores
                confidenceValue.classList.remove('score-high', 'score-medium', 'score-low');
                if (score >= 7) {
                    confidenceValue.classList.add('score-high');
                } else if (score >= 5) {
                    confidenceValue.classList.add('score-medium');
                } else {
                    confidenceValue.classList.add('score-low');
                }
            }

            // Animate voice score
            if (voiceValue && summary.voice_quality !== undefined) {
                const score = summary.voice_quality;
                voiceValue.textContent = `${score.toFixed(1)}/10`;
                if (voiceBar) {
                    voiceBar.style.width = `${(score / 10) * 100}%`;
                    voiceBar.style.transition = 'width 0.5s ease-out';
                }
                voiceValue.classList.remove('score-high', 'score-medium', 'score-low');
                if (score >= 7) {
                    voiceValue.classList.add('score-high');
                } else if (score >= 5) {
                    voiceValue.classList.add('score-medium');
                } else {
                    voiceValue.classList.add('score-low');
                }
            }

            // Animate body language score
            if (bodyLanguageValue && summary.body_language !== undefined) {
                const score = summary.body_language;
                bodyLanguageValue.textContent = `${score.toFixed(1)}/10`;
                if (bodyLanguageBar) {
                    bodyLanguageBar.style.width = `${(score / 10) * 100}%`;
                    bodyLanguageBar.style.transition = 'width 0.5s ease-out';
                }
                bodyLanguageValue.classList.remove('score-high', 'score-medium', 'score-low');
                if (score >= 7) {
                    bodyLanguageValue.classList.add('score-high');
                } else if (score >= 5) {
                    bodyLanguageValue.classList.add('score-medium');
                } else {
                    bodyLanguageValue.classList.add('score-low');
                }
            }

            // Animate overall physical score
            if (physicalScoreValue && summary.overall_physical_score !== undefined) {
                const score = summary.overall_physical_score;
                physicalScoreValue.textContent = `${score.toFixed(1)}/10`;
                if (physicalScoreBar) {
                    physicalScoreBar.style.width = `${(score / 10) * 100}%`;
                    physicalScoreBar.style.transition = 'width 0.5s ease-out';
                }
                // Add pulse animation for overall score
                physicalScoreValue.classList.remove('score-high', 'score-medium', 'score-low');
                if (score >= 7) {
                    physicalScoreValue.classList.add('score-high');
                } else if (score >= 5) {
                    physicalScoreValue.classList.add('score-medium');
                } else {
                    physicalScoreValue.classList.add('score-low');
                }
            }
        }

        async sendFinalAnalysis() {
            // Send all collected data for final analysis
            try {
                const formData = new FormData();
                this.videoFrames.forEach((frame, index) => {
                    formData.append('video_frames[]', frame);
                });
                this.audioSegments.forEach((segment, index) => {
                    formData.append('audio_segments[]', segment);
                });

                const response = await fetch('/analyze_physical', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ Physical analysis completed:', data.summary);
                    return data.analysis;
                }
            } catch (e) {
                console.error('Error sending final physical analysis:', e);
            }
            return null;
        }
    }

    // Interview State Management
    class InterviewSessionManager {
        constructor(duration, displayElement) {
            // Support both parameter styles for compatibility
            this.listeningTime = 0; // No thinking time - go directly to answering
            this.answerTime = duration || 30; // Use parameter or default to 30
            this.display = displayElement; // Store display element if provided
            this.remaining = duration || 30; // For compatibility with script.js
            this.listeningTimer = null;
            this.answerTimer = null;
            this.nextCountdownTimer = null;
            this.currentState = 'waiting_permissions';
            this.permissionsGranted = false;
            this.mediaStream = null; // Store media stream for cleanup
            this.physicalAnalyzer = new PhysicalAnalysisManager(); // Physical analysis manager
        }

        // Stop all media streams (camera and microphone)
        stopAllMedia() {
            console.log('üõë Stopping all media streams...');

            // Stop video stream tracks
            if (this.mediaStream) {
                this.mediaStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('‚úÖ Stopped track:', track.kind);
                });
                this.mediaStream = null;
            }

            // Stop video element
            const videoElement = document.getElementById('interviewVideo');
            if (videoElement && videoElement.srcObject) {
                const stream = videoElement.srcObject;
                stream.getTracks().forEach(track => {
                    track.stop();
                    console.log('‚úÖ Stopped video track:', track.kind);
                });
                videoElement.srcObject = null;
            }

            // Stop voice recognition media stream
            if (typeof voiceRecognition !== 'undefined' && voiceRecognition.mediaStream) {
                voiceRecognition.mediaStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('‚úÖ Stopped voice recognition track:', track.kind);
                });
                voiceRecognition.mediaStream = null;
            }

            // Stop audio context
            if (typeof voiceRecognition !== 'undefined' && voiceRecognition.audioContext) {
                voiceRecognition.audioContext.close().then(() => {
                    console.log('‚úÖ Audio context closed');
                }).catch(err => {
                    console.error('Error closing audio context:', err);
                });
            }
        }

        async requestPermissions() {
            console.log('üîê requestPermissions called');

            // UI Feedback: Show we are working
            const enableBtn = document.getElementById('enableCamera');
            const statusText = document.getElementById('statusText');

            if (enableBtn) {
                enableBtn.disabled = true;
                enableBtn.textContent = '‚åõ Checking System...';
            }
            if (statusText) statusText.textContent = 'Requesting camera & microphone access...';

            // Bypass strict client-side OTP check if server verified session exists
            const otpVerified = sessionStorage.getItem('otpVerified') === 'true';

            try {
                console.log('üîê Requesting camera and microphone permissions...');

                // Request camera and microphone permissions
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                console.log('‚úÖ Permissions granted successfully!');

                // Store stream
                this.mediaStream = stream;

                // Monitor stream health
                this.monitorStreamHealth(stream);

                // Permissions granted
                sessionStorage.setItem('cameraMicPermissions', 'true');
                this.permissionsGranted = true;

                // UI Update: Success
                if (enableBtn) enableBtn.textContent = '‚úÖ System Ready';
                if (statusText) statusText.textContent = 'System Ready! Starting interview...';

                // Setup Video Element
                const videoEl = document.getElementById('interviewVideo');
                if (videoEl) {
                    videoEl.srcObject = stream;
                    videoEl.style.display = 'block'; // Show video
                    // Ensure it plays
                    videoEl.play().catch(e => console.error("Video play error:", e));
                }

                // Hide Placeholder / Robot
                const placeholder = document.getElementById('cameraPlaceholder');
                const robot = document.getElementById('robotAnimation');
                if (placeholder) placeholder.style.display = 'none';
                if (robot) robot.style.display = 'none'; // Use real video if available

                // Initialize Voice Recognition
                if (typeof voiceRecognition !== 'undefined') {
                    voiceRecognition.initialize(stream);
                    voiceRecognition.mediaStream = stream;
                }

                // Initialize Physical Analysis
                if (videoEl) {
                    this.physicalAnalyzer.initialize(videoEl, stream);
                    this.physicalAnalyzer.startCollecting();
                    const indicator = document.getElementById('physicalAnalysisIndicator');
                    if (indicator) {
                        indicator.style.display = 'block';
                        indicator.classList.add('animate-in');
                    }
                }

                // Proceed to Interview after short delay
                setTimeout(() => {
                    this.startAISpeakingPhase();
                }, 1500);

            } catch (error) {
                console.error('‚ùå Permission error:', error);

                // Reset button slightly so they know something happened, but proceed to robot mode
                if (enableBtn) {
                    enableBtn.textContent = '‚ö†Ô∏è Camera blocked';
                }

                // Handle Error -> Fallback to Robot Mode
                this.handlePermissionError(error);
            }
        }

        monitorStreamHealth(stream) {
            stream.getVideoTracks().forEach(track => {
                track.onended = () => {
                    console.warn('‚ö†Ô∏è Video track ended unexpectedly');
                    // Optional: handle disconnect
                };
            });
            stream.getAudioTracks().forEach(track => {
                track.onended = () => {
                    console.warn('‚ö†Ô∏è Audio track ended unexpectedly');
                };
            });
        }

        handlePermissionError(error) {
            console.error('‚ö†Ô∏è Handling Permission Error:', error);

            // 1. Force Robot Display
            const robot = document.getElementById('robotAnimation');
            const placeholder = document.getElementById('cameraPlaceholder');
            const video = document.getElementById('interviewVideo');

            if (video) video.style.display = 'none';
            if (placeholder) placeholder.style.display = 'none';

            if (robot) {
                robot.style.display = 'flex';
                // Force visibility styles just in case
                robot.style.visibility = 'visible';
                robot.style.opacity = '1';
                console.log('ü§ñ Robot animation forced to display');
            } else {
                console.error('‚ùå Robot element missing in DOM!');
            }

            // 2. Set State
            this.permissionsGranted = true;
            sessionStorage.setItem('cameraMicPermissions', 'robot-mode');

            // Still show the warning but allow interview to proceed
            document.getElementById('permissionWarning').style.display = 'block';
            document.getElementById('permissionHelp').style.display = 'block';

            // Hide loading overlay!
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) overlay.style.display = 'none';

            const statusText = document.getElementById('statusText');
            const timeInfo = document.getElementById('timeInfo');

            if (error.name === 'NotAllowedError') {
                statusText.textContent = 'Permissions denied - Robot mode active';
                timeInfo.textContent = 'Interview will proceed with robot avatar (camera optional)';
            } else if (error.name === 'NotFoundError') {
                statusText.textContent = 'No camera/microphone found - Robot mode active';
                timeInfo.textContent = 'Interview will proceed with robot avatar';
            } else if (error.name === 'NotSupportedError') {
                statusText.textContent = 'Browser not supported - Robot mode active';
                timeInfo.textContent = 'Interview will proceed with robot avatar';
            } else {
                statusText.textContent = 'Permission error - Robot mode active';
                timeInfo.textContent = 'Interview will proceed with robot avatar: ' + error.message;
            }

            // Start interview even without camera permissions
            setTimeout(() => {
                this.startAISpeakingPhase();
            }, 1000);
        }

        startAISpeakingPhase() {
            console.log('üéØ startAISpeakingPhase called');
            if (!this.permissionsGranted) {
                console.warn('‚ö†Ô∏è Permissions not granted, cannot start speaking');
                return;
            }

            console.log('‚úÖ Permissions granted, proceeding with AI speaking');
            this.currentState = 'ai_speaking';
            const statusText = document.getElementById('statusText');
            const timeInfo = document.getElementById('timeInfo');
            const listeningTimerElement = document.getElementById('listeningTimer');
            const aiSpeakingIndicator = document.getElementById('aiSpeakingIndicator');

            // Update UI for AI speaking phase
            if (statusText) statusText.textContent = 'Rishi is Speaking';
            if (timeInfo) timeInfo.textContent = 'Listen carefully to the question...';
            if (listeningTimerElement) {
                listeningTimerElement.textContent = this.listeningTime;
                listeningTimerElement.className = 'timer ai-speaking';
            }

            // Show AI speaking indicator
            if (aiSpeakingIndicator) {
                aiSpeakingIndicator.style.display = 'flex';
            }

            // Get question text - ensure we have the question
            let questionText = '';
            // Try aiQuestionText first as it matches the HTML
            const questionTextElement = document.getElementById('aiQuestionText') || document.getElementById('questionText');
            if (questionTextElement) {
                questionText = questionTextElement.textContent || questionTextElement.innerText;
            }

            // Fallback: try to get from question card
            if (!questionText) {
                const questionCard = document.getElementById('questionCard');
                if (questionCard) {
                    const h3 = questionCard.querySelector('h3');
                    if (h3) {
                        questionText = h3.textContent || h3.innerText;
                    }
                }
            }

            if (!questionText) {
                console.error('‚ùå Could not find question text');
                // Continue anyway
                setTimeout(() => this.startListeningPhase(), 1000);
                return;
            }

            const questionNumber = this.getCurrentQuestionNumber();
            const fullQuestion = `Question ${questionNumber}. ${questionText}`;

            console.log('üó£Ô∏è Rishi will speak:', fullQuestion);

            // Ensure TTS is ready
            if (typeof textToSpeech === 'undefined') {
                console.error('‚ùå TTS not available');
                setTimeout(() => this.startListeningPhase(), 2000);
                return;
            }

            // Check if speech synthesis is supported
            if (!('speechSynthesis' in window)) {
                console.error('‚ùå Speech synthesis not supported in this browser');
                setTimeout(() => this.startListeningPhase(), 2000);
                return;
            }

            console.log('üé§ Calling textToSpeech.speakQuestion...');
            // Rishi speaks the question using TTS with retry logic
            textToSpeech.speakQuestion(fullQuestion)
                .then(() => {
                    console.log('‚úÖ Rishi finished speaking question');
                    // No thinking time - go directly to answering phase and auto-start microphone
                    setTimeout(() => {
                        this.startAnsweringPhase();
                        // Auto-start microphone immediately
                        this.autoStartMicrophone();
                    }, 300);
                })
                .catch(error => {
                    console.error('‚ùå TTS error, continuing without speech:', error);
                    // Even if TTS fails, go directly to answering
                    setTimeout(() => {
                        this.startAnsweringPhase();
                        // Auto-start microphone immediately
                        this.autoStartMicrophone();
                    }, 500);
                });
        }
        autoStartMicrophone() {
            console.log('üé§ autoStartMicrophone called');
            if (this.permissionsGranted && typeof voiceRecognition !== 'undefined') {
                try {
                    if (!voiceRecognition.isListening) {
                        voiceRecognition.startListening();
                        updateVoiceUI('listening');
                        console.log('‚úÖ Microphone auto-started');
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Could not auto-start microphone:', error);
                }
            } else {
                console.warn('‚ö†Ô∏è Cannot auto-start microphone: permissions not granted or voiceRecognition missing');
            }
        }

        startAnsweringPhase() {
            console.log('üéØ startAnsweringPhase called, answerTime:', this.answerTime);
            this.currentState = 'answering';
            this.remaining = this.answerTime; // Initialize remaining time
            console.log('‚è∞ Timer initialized with remaining:', this.remaining);
            const listeningTimerElement = document.getElementById('listeningTimer');
            const answerTimerElement = document.getElementById('answerTimer');
            const statusText = document.getElementById('statusText');
            const timeInfo = document.getElementById('timeInfo');
            const answerSection = document.getElementById('answerSection');
            const questionCard = document.getElementById('questionCard');
            const chatbotButtonContainer = document.getElementById('chatbotButtonContainer');

            // Hide behavioral questions
            const questionType = questionCard ? questionCard.querySelector('.question-type')?.textContent.toLowerCase() : '';
            if (questionType && 'behavioral' in questionType) {
                if (questionCard) questionCard.style.display = 'none';
            }

            // Show chatbot button instead of answer section directly
            if (chatbotButtonContainer) {
                chatbotButtonContainer.style.display = 'block';
            }
            // Keep answer section hidden until chatbot button is clicked
            if (answerSection) {
                answerSection.style.display = 'none';
            }

            if (questionCard) {
                questionCard.classList.add('minimized');
            }

            // Ensure microphone is still active if it was auto-started
            if (this.permissionsGranted && typeof voiceRecognition !== 'undefined') {
                // Microphone should already be running from autoStartMicrophone
                // But ensure it's active
                try {
                    if (!voiceRecognition.isListening) {
                        voiceRecognition.startListening();
                        updateVoiceUI('listening');
                        console.log('‚úÖ Microphone started in answering phase');
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Could not ensure microphone is active:', error);
                }
            }

            // Start collecting physical analysis data immediately
            if (this.physicalAnalyzer && this.permissionsGranted) {
                this.physicalAnalyzer.startCollecting();
                // Show physical analysis indicator with animations
                const indicator = document.getElementById('physicalAnalysisIndicator');
                if (indicator) {
                    indicator.style.display = 'block';
                    indicator.classList.add('animate-in');
                }
                console.log('‚úÖ Physical analysis active - showing animated indicators');
            }

            // Update UI for answering phase
            if (listeningTimerElement) listeningTimerElement.className = 'timer completed';
            if (answerTimerElement) answerTimerElement.className = 'timer active';
            if (statusText) statusText.textContent = 'Answer the Question';
            if (timeInfo) timeInfo.textContent = `Respond now: ${this.remaining} seconds remaining`;

            this.answerTimer = setInterval(() => {
                console.log('‚è∞ Timer tick, remaining before:', this.remaining);
                this.remaining--;
                console.log('‚è∞ Timer tick, remaining after:', this.remaining);

                if (answerTimerElement) {
                    answerTimerElement.textContent = this.remaining;
                    // Show warning when 5 seconds remaining (for 30-second timer)
                    if (this.remaining <= 5) {
                        answerTimerElement.classList.add('warning');
                    }
                }

                if (this.remaining <= 0) {
                    console.log('‚è∞ Timer reached 0, submitting answer');
                    clearInterval(this.answerTimer);
                    this.submitAnswer();
                }
            }, 1000);
        }

        async submitAnswer() {
            // Stop collecting physical data
            if (this.physicalAnalyzer) {
                this.physicalAnalyzer.stopCollecting();
                // Send final analysis
                await this.physicalAnalyzer.sendFinalAnalysis();
            }

            const answer = document.getElementById('answer').value;
            if (!answer.trim()) {
                document.getElementById('answer').value = '[No response provided]';
            }
            // Trigger form submission
            document.getElementById('answerForm').dispatchEvent(new Event('submit'));
        }

        startNextCountdown(seconds = 5) {
            this.currentState = 'feedback';
            let timeLeft = seconds;
            const countdownElement = document.getElementById('nextCountdown');
            const nextButton = document.getElementById('nextQuestionBtn');

            countdownElement.textContent = timeLeft;

            this.nextCountdownTimer = setInterval(() => {
                timeLeft--;
                countdownElement.textContent = timeLeft;

                if (timeLeft <= 0) {
                    clearInterval(this.nextCountdownTimer);
                    this.goToNextQuestion();
                }
            }, 1000);

            nextButton.onclick = () => {
                clearInterval(this.nextCountdownTimer);
                this.loadNextQuestion();
            };
        }

        async loadNextQuestion() {
            // IMPORTANT: do NOT stop camera/mic between questions.
            // We keep the same media stream and just fetch the next question.
            try {
                // Stop timers and TTS, but keep media running
                this.stopAllTimers();
                if (typeof textToSpeech !== 'undefined') {
                    textToSpeech.stop();
                }

                // Hide feedback UI
                const feedbackSection = document.getElementById('feedbackSection');
                if (feedbackSection) feedbackSection.style.display = 'none';

                // Clear answer UI and reset chatbot button
                const answerTextarea = document.getElementById('answer');
                if (answerTextarea) answerTextarea.value = '';
                const voicePreview = document.getElementById('voicePreview');
                if (voicePreview) voicePreview.textContent = '';

                // Hide answer section, show chatbot button
                const answerSectionEl = document.getElementById('answerSection');
                const chatbotButtonContainerEl = document.getElementById('chatbotButtonContainer');
                if (answerSectionEl) answerSectionEl.style.display = 'none';
                if (chatbotButtonContainerEl) chatbotButtonContainerEl.style.display = 'block';

                // Fetch next question from server (also triggers sequential HF generation server-side)
                const res = await fetch('/get_next_question');
                if (!res.ok) throw new Error('Failed to fetch next question: ' + res.status);
                const data = await res.json();

                if (data.completed) {
                    console.log('‚úÖ Interview completed - redirecting to results');
                    this.stopEverything();
                    window.location.href = '/results';
                    return;
                }

                // Update question text in BOTH places
                const questionTextEl = document.getElementById('questionText');
                if (questionTextEl) questionTextEl.textContent = data.question || '';
                const aiQuestionTextEl = document.getElementById('aiQuestionText');
                if (aiQuestionTextEl) aiQuestionTextEl.textContent = data.question || '';

                // Update meta (type) and hide if behavioral
                const typeEl = document.querySelector('.question-type');
                const questionCard = document.getElementById('questionCard');
                const questionType = (data.type || 'technical').toString().toLowerCase();

                if (typeEl) {
                    typeEl.textContent = `${questionType.charAt(0).toUpperCase()}${questionType.slice(1)} Question`;
                }

                // Hide behavioral questions
                if (questionCard && questionType === 'behavioral') {
                    questionCard.style.display = 'none';
                } else if (questionCard) {
                    questionCard.style.display = 'block';
                }

                // Reset chatbot button and answer section
                if (chatbotButtonContainerEl) chatbotButtonContainerEl.style.display = 'block';
                if (answerSectionEl) answerSectionEl.style.display = 'none';

                // Update progress text if visible
                const progressInfo = document.querySelector('.progress-info');
                if (progressInfo && data.question_num && data.total_questions) {
                    if (progressInfo.firstChild) {
                        progressInfo.firstChild.textContent = `Question ${data.question_num} of ${data.total_questions} `;
                    } else {
                        progressInfo.textContent = `Question ${data.question_num} of ${data.total_questions} `;
                    }
                }

                // Restart interview flow for the new question
                this.startAISpeakingPhase();
                // Start mic automatically (safe if browser blocks)
                if (typeof this.autoStartMicrophone === 'function') {
                    this.autoStartMicrophone();
                }
            } catch (e) {
                console.error('‚ùå Error loading next question:', e);
                // Don't alert - just try to recover or redirect
                if (e.message && e.message.includes('400')) {
                    window.location.href = '/results';
                }
            }
        }

        stopAllTimers() {
            if (this.listeningTimer) clearInterval(this.listeningTimer);
            if (this.answerTimer) clearInterval(this.answerTimer);
            if (this.nextCountdownTimer) clearInterval(this.nextCountdownTimer);
        }

        // Stop everything including media
        stopEverything() {
            console.log('üõë Stopping everything...');
            this.stopAllTimers();
            this.stopAllMedia();

            // Stop physical analysis
            if (this.physicalAnalyzer) {
                this.physicalAnalyzer.stopCollecting();
            }

            // Stop text-to-speech
            if (typeof textToSpeech !== 'undefined') {
                textToSpeech.stop();
            }

            // Stop voice recognition
            if (typeof voiceRecognition !== 'undefined') {
                voiceRecognition.stopListening();
            }

            // Clear permission storage
            sessionStorage.removeItem('cameraMicPermissions');
        }

        getCurrentQuestionNumber() {
            const progressInfo = document.querySelector('.progress-info');
            const text = progressInfo ? progressInfo.textContent : '';
            const match = text.match(/Question (\d+) of/);
            return match ? match[1] : '1';
        }

        // Compatibility method for script.js InterviewTimer
        updateDisplay() {
            if (this.display) {
                const minutes = Math.floor(this.remaining / 60);
                const seconds = this.remaining % 60;
                this.display.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

    }

    // Global instances - Initialize safely after DOM loads
    let interviewTimer = null;
    let textToSpeech = null;

    // Initialize global instances after DOM is ready
    function initializeGlobalInstances() {
        try {
            const answerTimerElement = document.getElementById('answerTimer');
            if (answerTimerElement) {
                interviewTimer = new InterviewSessionManager(30, answerTimerElement); // Pass parameters for compatibility
                // Make it globally accessible for testing
                window.interviewManager = interviewTimer;
                console.log('‚úÖ InterviewTimer initialized successfully');
            } else {
                console.warn('‚ö†Ô∏è answerTimer element not found during initialization');
                // Create with null display element
                interviewTimer = new InterviewSessionManager(30, null);
                window.interviewManager = interviewTimer;
            }

            textToSpeech = new TextToSpeech();
            console.log('‚úÖ TextToSpeech initialized successfully');

            // Setup button listeners
            setupButtonListeners();
        } catch (error) {
            console.error('‚ùå Error initializing global instances:', error);
            // Create fallback instances
            interviewTimer = { start: () => { }, stop: () => { } };
            textToSpeech = { speakQuestion: () => Promise.resolve() };
            window.interviewManager = interviewTimer;
        }
    }

    // Setup event listeners for UI buttons
    function setupButtonListeners() {
        // Chatbot Button
        const chatbotBtn = document.getElementById('chatbotButton');
        if (chatbotBtn) {
            chatbotBtn.addEventListener('click', function (e) {
                e.preventDefault();
                document.getElementById('chatbotButtonContainer').classList.add('hidden');
                document.getElementById('answerSection').classList.add('visible');
                // Auto focus answer box
                const answerBox = document.getElementById('answer');
                if (answerBox) answerBox.focus();
            });
        }

        // Close Answer Section Button
        const closeBtn = document.getElementById('closeAnswerSection');
        if (closeBtn) {
            closeBtn.addEventListener('click', function (e) {
                e.preventDefault();
                document.getElementById('answerSection').classList.remove('visible');
                document.getElementById('chatbotButtonContainer').classList.remove('hidden');
            });
        }



        // Main Skip Button (New)
        const skipBtnMain = document.getElementById('skipButtonMain');
        if (skipBtnMain) {
            skipBtnMain.addEventListener('click', function (e) {
                e.preventDefault();
                if (confirm('Are you sure you want to skip this question?')) {
                    if (window.interviewManager) {
                        window.interviewManager.loadNextQuestion();
                    } else {
                        window.location.reload();
                    }
                }
            });
        }
    }

    // CSS Fix Function - Ensures styles are applied after navigation
    function applyCSSFixes() {
        // Force reflow to trigger CSS recalculation
        document.body.offsetHeight;

        // Re-apply all critical styles
        const criticalElements = [
            '.interview-room',
            '.video-section',
            '.question-section',
            '.interview-header',
            '.timer',
            '.btn',
            '.feature-card',
            '.question-card',
            '.answer-section',
            '.feedback-section'
        ];

        criticalElements.forEach(selector => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(el => {
                // Force style recalculation
                const computedStyle = window.getComputedStyle(el);
                const display = computedStyle.display;

                // If element should be visible but isn't, fix it
                if (display === 'none' && !el.hasAttribute('data-hidden')) {
                    // Check if parent is hiding it
                    const parentStyle = window.getComputedStyle(el.parentElement);
                    if (parentStyle.display !== 'none') {
                        el.style.display = '';
                        el.style.display = computedStyle.display || 'block';
                    }
                }

                // Ensure classes are applied
                if (!el.className.includes(selector.replace('.', ''))) {
                    el.classList.add(selector.replace('.', ''));
                }
            });
        });

        // Force all stylesheets to be active
        try {
            for (let i = 0; i < document.styleSheets.length; i++) {
                const sheet = document.styleSheets[i];
                if (sheet && sheet.cssRules) {
                    // Access rules to ensure stylesheet is loaded
                    try {
                        const rules = sheet.cssRules;
                        console.log(`‚úÖ Stylesheet ${i} loaded with ${rules.length} rules`);
                    } catch (e) {
                        console.warn(`‚ö†Ô∏è Cannot access stylesheet ${i} (CORS or other issue)`);
                    }
                }
            }
        } catch (e) {
            console.warn('Error accessing stylesheets:', e);
        }

        console.log('‚úÖ CSS fixes applied');
    }

    // Main interview start function
    // Main interview start function - Robust Version
    function startInterview() {
        console.log('üéØ startInterview() called');

        // Safety: Ensure loading overlay is hidden
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) overlay.style.display = 'none';

        try {
            // Ensure interview manager is initialized
            if (!window.interviewManager) {
                console.error('‚ùå interviewManager not found, initializing...');
                initializeGlobalInstances();
            }

            if (window.interviewManager) {
                console.log('‚úÖ Calling interviewManager.requestPermissions()...');
                // This is the main entry point
                window.interviewManager.requestPermissions();
            } else {
                throw new Error('Failed to initialize interview manager');
            }
        } catch (e) {
            console.error('‚ùå Critical Error in startInterview:', e);
            alert('Could not start interview: ' + e.message);
            // Attempt to restore UI
            const placeholder = document.getElementById('cameraPlaceholder');
            if (placeholder) placeholder.style.display = 'flex';
        }
    }

    // Test robot animation function (for debugging)
    function showRobotForTesting() {
        try {
            console.log('ü§ñ Manual robot test triggered');

            // Set permissions as granted for robot mode
            if (window.interviewManager) {
                window.interviewManager.permissionsGranted = true;
            }
            sessionStorage.setItem('cameraMicPermissions', 'robot-mode');

            // Show robot animation
            const robotElement = document.getElementById('robotAnimation');
            const placeholderElement = document.getElementById('cameraPlaceholder');
            const warningElement = document.getElementById('permissionWarning');

            if (robotElement) {
                robotElement.style.display = 'flex';
                console.log('ü§ñ Robot animation element found and displayed');
            } else {
                console.error('‚ùå Robot animation element not found!');
                return; // Exit early if robot element doesn't exist
            }

            if (placeholderElement) {
                placeholderElement.style.display = 'none';
            }

            if (warningElement) {
                warningElement.style.display = 'none';
            }

            console.log('ü§ñ Robot animation activated manually');

            // Start the interview
            setTimeout(() => {
                console.log('ü§ñ Starting interview after robot animation...');
                if (typeof startInterview === 'function') {
                    startInterview();
                } else {
                    console.error('‚ùå startInterview function not found');
                }
            }, 1000);
        } catch (error) {
            console.error('‚ùå Error in showRobotForTesting:', error);
            // Fallback: try to start interview directly
            setTimeout(() => {
                if (typeof fallbackStartInterview === 'function') {
                    console.log('üîÑ Fallback: trying fallbackStartInterview...');
                    fallbackStartInterview();
                }
            }, 1000);
        }
    }

    // Fallback function to start interview if main method fails
    function fallbackStartInterview() {
        try {
            console.log('üîÑ Starting interview with fallback method...');

            // Show robot animation
            const robotElement = document.getElementById('robotAnimation');
            if (robotElement) {
                robotElement.style.display = 'flex';
            }

            // Hide other elements
            const placeholderElement = document.getElementById('cameraPlaceholder');
            const warningElement = document.getElementById('permissionWarning');
            if (placeholderElement) placeholderElement.style.display = 'none';
            if (warningElement) warningElement.style.display = 'none';

            // Try to start speaking directly
            setTimeout(() => {
                try {
                    // Get question text
                    const questionTextElement = document.getElementById('aiQuestionText') || document.getElementById('questionText');
                    let questionText = '';
                    if (questionTextElement) {
                        questionText = questionTextElement.textContent || questionTextElement.innerText;
                    }

                    if (!questionText) {
                        const questionCard = document.getElementById('questionCard');
                        if (questionCard) {
                            const h3 = questionCard.querySelector('h3');
                            if (h3) {
                                questionText = h3.textContent || h3.innerText;
                            }
                        }
                    }

                    if (questionText && textToSpeech && typeof textToSpeech.speakQuestion === 'function') {
                        const questionNumber = 1; // Assume first question
                        const fullQuestion = `Question ${questionNumber}. ${questionText}`;
                        console.log('üó£Ô∏è Fallback: Rishi speaking:', fullQuestion);

                        textToSpeech.speakQuestion(fullQuestion)
                            .then(() => {
                                console.log('‚úÖ Fallback: Rishi finished speaking');
                                // Start answering phase
                                if (window.interviewManager && window.interviewManager.startAnsweringPhase) {
                                    window.interviewManager.startAnsweringPhase();
                                }
                            })
                            .catch(error => {
                                console.error('‚ùå Fallback TTS error:', error);
                            });
                    } else {
                        console.error('‚ùå Fallback: No question text or TTS not available');
                    }
                } catch (error) {
                    console.error('‚ùå Fallback interview start failed:', error);
                }
            }, 1500);
        } catch (error) {
            console.error('‚ùå Critical error in fallbackStartInterview:', error);
        }
    }

    // Consolidating startup logic
    document.addEventListener('DOMContentLoaded', function () {
        try {
            console.log('üöÄ Interview room DOMContentLoaded triggered');
            initializeGlobalInstances();

            // Force visibility
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) overlay.style.display = 'none';
            document.body.classList.add('loaded');

            // Force reflow and apply fixes
            if (typeof applyCSSFixes === 'function') {
                applyCSSFixes();
            }

            // Auto-start or show permission warning
            setTimeout(() => {
                const robot = document.getElementById('robotAnimation');
                if (!robot || robot.style.display === 'none') {
                    console.log('ü§ñ Auto-starting interview with robot animation...');
                    showRobotForTesting();
                }
            }, 1000);

        } catch (error) {
            console.error('‚ùå Initialization failure:', error);
            const manualBtn = document.getElementById('manualStartBtn');
            if (manualBtn) manualBtn.style.display = 'inline-block';
        }
    });

    // Request permissions button (optional - for camera access)
    document.getElementById('requestPermissions').addEventListener('click', function () {
        console.log('üéØ Enable Camera & Microphone button clicked');
        interviewTimer.requestPermissions();
    });

    // Enable camera button
    document.getElementById('enableCamera').addEventListener('click', function () {
        console.log('üéØ Enable Camera button clicked');
        startInterview();
    });

    // Voice recognition event listeners
    document.getElementById('voiceButton').addEventListener('click', function () {
        if (!interviewTimer.permissionsGranted) {
            alert('Please start the interview first by clicking "Start Interview"');
            return;
        }
        if (typeof voiceRecognition !== 'undefined') {
            voiceRecognition.startListening();
            updateVoiceUI('listening');
        } else {
            alert('Voice recognition not available');
        }
    });

    document.getElementById('stopVoiceButton').addEventListener('click', function () {
        if (typeof voiceRecognition !== 'undefined') {
            voiceRecognition.stopListening();
            updateVoiceUI('stopped');
        }
    });

    function updateVoiceUI(state) {
        const voiceButton = document.getElementById('voiceButton');
        const stopButton = document.getElementById('stopVoiceButton');
        const status = document.getElementById('voiceStatus');
        const visualizer = document.getElementById('visualizer');
        const recordingIndicator = document.getElementById('recordingIndicator');

        if (!status) return;

        switch (state) {
            case 'listening':
                if (voiceButton) voiceButton.style.display = 'none';
                if (stopButton) stopButton.style.display = 'inline-block';
                status.textContent = 'Listening... Speak your response now';
                status.className = 'voice-status listening';
                if (visualizer) visualizer.style.display = 'block';
                if (recordingIndicator) recordingIndicator.style.display = 'block';
                break;
            case 'stopped':
                if (voiceButton) voiceButton.style.display = 'inline-block';
                if (stopButton) stopButton.style.display = 'none';
                status.textContent = 'Ready to speak your response';
                status.className = 'voice-status ready';
                if (visualizer) visualizer.style.display = 'none';
                if (recordingIndicator) recordingIndicator.style.display = 'none';
                break;
            case 'error':
                if (voiceButton) voiceButton.style.display = 'inline-block';
                if (stopButton) stopButton.style.display = 'none';
                status.textContent = 'Voice input error - try again';
                status.className = 'voice-status error';
                if (visualizer) visualizer.style.display = 'none';
                if (recordingIndicator) recordingIndicator.style.display = 'none';
                break;
        }
    }

    // Update answer text when voice recognition returns results
    if (typeof voiceRecognition !== 'undefined') {
        voiceRecognition.onResult = function (transcript) {
            console.log('üí¨ Voice recognition result:', transcript);
            const answerTextarea = document.getElementById('answer');
            if (answerTextarea) {
                answerTextarea.value = transcript;
            }
            const voicePreview = document.getElementById('voicePreview');
            if (voicePreview) {
                voicePreview.textContent = transcript;
            }
        };
    }

    // Form submission handler
    document.getElementById('answerForm').addEventListener('submit', function (e) {
        e.preventDefault();
        console.log('üì§ Form submitted');

        const answer = document.getElementById('answer').value;
        if (!answer.trim()) {
            document.getElementById('answer').value = '[No response provided]';
        }

        // Stop all timers
        interviewTimer.stopAllTimers();

        // Stop voice recognition if available
        if (typeof voiceRecognition !== 'undefined') {
            voiceRecognition.stopListening();
        }

        // Stop TTS if available
        textToSpeech.stop();

        // Stop voice recognition and its media stream
        if (typeof voiceRecognition !== 'undefined') {
            voiceRecognition.stopListening();
        }

        // Show loading
        document.getElementById('loadingOverlay').style.display = 'flex';

        // Submit answer
        const formData = new FormData(this);

        fetch('/submit_answer', {
            method: 'POST',
            body: formData
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok: ' + response.status);
                }
                return response.json();
            })
            .then(data => {
                console.log('‚úÖ Submit answer response:', data);
                document.getElementById('loadingOverlay').style.display = 'none';

                // Hide feedback section during interview (only show on completion)
                if (data.completed) {
                    // Show feedback only when interview is completed
                    document.getElementById('feedbackContent').innerHTML = `
                    <p><strong>Rishi Assessment:</strong> ${data.score}/10</p>
                    <p><strong>Feedback:</strong> ${data.feedback}</p>
                    <p style="margin-top: 1rem; font-weight: bold; color: #667eea;">üéâ Interview Completed! Redirecting to results...</p>
                `;

                    document.getElementById('feedbackSection').style.display = 'block';
                    document.getElementById('feedbackSection').scrollIntoView({ behavior: 'smooth' });

                    document.getElementById('nextQuestionBtn').textContent = 'View Results Now';
                    document.getElementById('nextQuestionBtn').onclick = function () {
                        interviewTimer.stopEverything();
                        window.location.href = '/results';
                    };
                    document.querySelector('.auto-next-countdown').style.display = 'none';

                    // Stop all media when interview is completed
                    interviewTimer.stopAllMedia();

                    // Auto-redirect after 2 seconds
                    setTimeout(() => {
                        interviewTimer.stopEverything();
                        window.location.href = '/results';
                    }, 2000);
                } else {
                    // During interview: hide feedback, auto-advance to next question
                    document.getElementById('feedbackSection').style.display = 'none';
                    // Load next question without reloading the page (keeps camera/mic stable)
                    setTimeout(() => {
                        interviewTimer.loadNextQuestion();
                    }, 300);
                }
            })
            .catch(error => {
                console.error('‚ùå Error submitting answer:', error);
                document.getElementById('loadingOverlay').style.display = 'none';
                alert('Error submitting response. Please try again.');
            });
    });


    // Clean up when page is unloaded (user navigates away or closes tab)
    window.addEventListener('beforeunload', function () {
        console.log('üö™ Page unloading - cleaning up media streams...');
        interviewTimer.stopEverything();
    });

    // Clean up when page becomes hidden (tab switched, minimized, etc.)
    document.addEventListener('visibilitychange', function () {
        if (document.hidden) {
            console.log('üëÅÔ∏è Page hidden - stopping media...');
            // Optionally stop media when page is hidden
            // interviewTimer.stopAllMedia();
        }
    });

    // Handle page exit gracefully
    window.addEventListener('pagehide', function () {
        console.log('üëã Page hiding - cleaning up...');
        interviewTimer.stopEverything();
    });

    // Enhanced CSS application on page load
    window.addEventListener('load', function () {
        // Apply CSS fixes after all resources are loaded
        setTimeout(() => {
            applyCSSFixes();
            console.log('‚úÖ CSS fixes applied after full page load');
        }, 100);


        // Re-apply styles when DOM changes (for dynamic content)
        const observer = new MutationObserver(function (mutations) {
            let shouldApplyFixes = false;

            mutations.forEach(function (mutation) {
                if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                    // New elements added - check if they need styling
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType === 1) { // Element node
                            const classes = node.className || '';
                            if (classes.includes('question') ||
                                classes.includes('answer') ||
                                classes.includes('timer') ||
                                classes.includes('btn')) {
                                shouldApplyFixes = true;
                            }
                        }
                    });
                }

                if (mutation.type === 'attributes' &&
                    (mutation.attributeName === 'class' || mutation.attributeName === 'style')) {
                    shouldApplyFixes = true;
                }
            });

            if (shouldApplyFixes) {
                // Debounce CSS fixes to avoid excessive calls
                clearTimeout(window.cssFixTimeout);
                window.cssFixTimeout = setTimeout(() => {
                    applyCSSFixes();
                }, 50);
            }
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['class', 'style']
        });

        // Apply CSS fixes when page becomes visible (handles back/forward navigation)
        document.addEventListener('visibilitychange', function () {
            if (!document.hidden) {
                setTimeout(() => {
                    applyCSSFixes();
                    console.log('‚úÖ CSS fixes applied after visibility change');
                }, 100);
            }
        });

        console.log('üéØ All event listeners attached - TTS is ready!');
    });

    // Manual start button for debugging
    function manualStartInterview() {
        console.log('üîò Manual start button clicked');
        showRobotForTesting();
    }
</script>

<style>
    /* Premium Design System Overrides */
    :root {
        --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        --accent-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        --dark-bg: #1a1a2e;
        --glass-bg: rgba(255, 255, 255, 0.05);
        --glass-border: rgba(255, 255, 255, 0.1);
    }

    body.interview-mode {
        background-color: var(--dark-bg);
        color: #e0e0e0;
        font-family: 'Inter', 'Outfit', sans-serif;
    }

    .interview-room {
        background: radial-gradient(circle at top right, #16213e, #1a1a2e);
        min-height: 100vh;
        padding-top: 2rem;
    }

    .interview-header h2 {
        font-weight: 800;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: -1px;
    }

    .video-container {
        border-radius: 24px;
        overflow: hidden;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        border: 1px solid var(--glass-border);
        background: #000;
    }

    /* Live Analysis Panel Enhancement */
    #physicalAnalysisIndicator {
        background: rgba(26, 26, 46, 0.85) !important;
        backdrop-filter: blur(15px) !important;
        border: 1px solid var(--glass-border) !important;
        border-radius: 20px !important;
        padding: 20px !important;
        width: 240px !important;
    }

    .analysis-item {
        margin: 12px 0 !important;
    }

    .analysis-label {
        font-size: 12px !important;
        color: #aaa !important;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .analysis-value {
        font-family: 'Monaco', monospace;
        color: #fff !important;
        font-size: 14px !important;
    }

    .analysis-bar {
        background: rgba(255, 255, 255, 0.1) !important;
        height: 4px !important;
    }

    /* Chatbot & Skip Buttons */
    .chatbot-btn {
        background: var(--primary-gradient);
        border-radius: 12px;
        font-weight: 700;
        letter-spacing: 0.5px;
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }

    #skipButtonMain {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid var(--glass-border);
        color: #fff;
        border-radius: 12px;
        font-weight: 600;
        backdrop-filter: blur(5px);
    }

    #skipButtonMain:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
    }

    /* Question Bubble Enhancement */
    .ai-speech-bubble {
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        border: 1px solid var(--glass-border);
        border-radius: 20px;
        padding: 25px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        max-width: 80%;
    }

    #aiQuestionText {
        font-size: 1.25rem;
        font-weight: 500;
        line-height: 1.6;
        color: #fff;
        display: block !important;
        /* Failsafe */
        visibility: visible !important;
    }

    .permission-warning {
        background: var(--glass-bg);
        backdrop-filter: blur(20px);
        border: 1px solid var(--glass-border);
    }

    /* Physical Analysis Animation Styles */
    @keyframes slideInLeft {
        from {
            opacity: 0;
            transform: translateX(-50px);
        }

        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    @keyframes pulse {

        0%,
        100% {
            transform: scale(1);
            opacity: 1;
        }

        50% {
            transform: scale(1.05);
            opacity: 0.9;
        }
    }

    .animate-in {
        animation: slideInLeft 0.5s ease-out;
    }

    .visible {
        display: block !important;
        animation: fadeIn 0.4s ease-out;
    }

    .hidden {
        display: none !important;
    }

    .analysis-item {
        margin: 8px 0;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .analysis-label {
        flex: 0 0 100px;
        font-size: 11px;
        opacity: 0.9;
    }

    .analysis-value {
        flex: 0 0 50px;
        font-weight: 700;
        text-align: right;
        transition: all 0.3s ease;
    }

    .analysis-bar {
        flex: 1;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        overflow: hidden;
        position: relative;
    }

    .analysis-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
        border-radius: 10px;
        transition: width 0.5s ease-out;
        box-shadow: 0 2px 8px rgba(79, 172, 254, 0.5);
    }

    .score-high {
        color: #4facfe;
        animation: pulse 2s infinite;
    }

    .score-medium {
        color: #f39c12;
    }

    .score-low {
        color: #e74c3c;
    }

    /* AI Avatar Pulsing Animation */
    .ai-avatar {
        position: relative;
        width: 60px;
        height: 60px;
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 10px auto 0;
    }

    .ai-avatar .core {
        width: 30px;
        height: 30px;
        background: #00d2ff;
        border-radius: 50%;
        box-shadow: 0 0 20px #00d2ff, 0 0 40px #00d2ff, 0 0 60px #00d2ff;
        z-index: 2;
        animation: corePulse 2s infinite;
    }

    .ai-avatar .pulse-ring {
        position: absolute;
        width: 30px;
        height: 30px;
        background: transparent;
        border: 2px solid #00d2ff;
        border-radius: 50%;
        animation: pulseRing 2s infinite;
    }

    @keyframes corePulse {

        0%,
        100% {
            transform: scale(1);
            box-shadow: 0 0 20px #00d2ff, 0 0 40px #00d2ff, 0 0 60px #00d2ff;
        }

        50% {
            transform: scale(1.1);
            box-shadow: 0 0 30px #00d2ff, 0 0 60px #00d2ff, 0 0 90px #00d2ff;
        }
    }

    @keyframes pulseRing {
        0% {
            transform: scale(1);
            opacity: 1;
            border-color: #00d2ff;
        }

        50% {
            transform: scale(1.5);
            opacity: 0.7;
            border-color: #00aaff;
        }

        100% {
            transform: scale(2.5);
            opacity: 0;
            border-color: #0088ff;
        }
    }

    /* Robot Screen Content Layout */
    .screen-content {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        padding: 10px;
    }

    .screen-text {
        font-size: 14px;
        font-weight: bold;
        color: #00d2ff;
        margin-bottom: 5px;
        text-shadow: 0 0 10px #00d2ff;
    }

    .screen-pulse {
        width: 20px;
        height: 2px;
        background: #00d2ff;
        margin: 5px auto;
        border-radius: 1px;
        animation: screenPulse 1.5s infinite;
    }

    @keyframes screenPulse {

        0%,
        100% {
            opacity: 0.3;
        }

        50% {
            opacity: 1;
        }
    }

    /* OTP Modal Styles */
    .otp-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fadeIn 0.3s ease-out;
    }

    .otp-modal-content {
        background: white;
        padding: 3rem;
        border-radius: 25px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        max-width: 500px;
        width: 90%;
        text-align: center;
        animation: slideUp 0.4s ease-out;
    }

    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(30px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .otp-modal-content h3 {
        font-size: 2rem;
        margin-bottom: 1rem;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .otp-modal-content p {
        color: #7f8c8d;
        margin-bottom: 2rem;
        font-size: 1.1rem;
    }

    .otp-display {
        background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
        padding: 1.5rem;
        border-radius: 15px;
        margin-bottom: 1.5rem;
    }

    .otp-input-group {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
        align-items: center;
    }

    .otp-input {
        flex: 1;
        padding: 15px 20px;
        font-size: 1.5rem;
        text-align: center;
        letter-spacing: 0.5rem;
        border: 3px solid #e0e0e0;
        border-radius: 15px;
        font-weight: bold;
        transition: all 0.3s ease;
    }

    .otp-input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.15);
        transform: scale(1.02);
    }

    .otp-error {
        color: var(--danger);
        background: rgba(231, 76, 60, 0.1);
        padding: 1rem;
        border-radius: 10px;
        margin-top: 1rem;
        font-weight: 600;
    }

    .otp-help {
        margin-top: 1.5rem;
        padding-top: 1.5rem;
        border-top: 2px solid #e0e0e0;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }
</style>
{% endblock %}