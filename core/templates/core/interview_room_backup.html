{% extends "core/base_interview.html" %}
{% load static %}

{% block title %}Interview Room - Question {{ question_num }}{% endblock %}
{% block body_class %}interview-mode{% endblock %}

{% block content %}
<div class="interview-room">
    <div class="container">
        <!-- OTP Verification Modal - Show before camera/mic access -->
        <!-- Permission Warning - Hidden by default, can be shown if needed -->
        <div id="permissionWarning" class="permission-warning" style="display: none;">
            <div class="warning-content">
                <h4>üé• Camera & Microphone Optional</h4>
                <p>The interview will proceed with robot animation. Camera access is optional for enhanced experience.
                </p>
                <div class="permission-steps">
                    <p><strong>Interview starting automatically...</strong></p>
                    <div class="loading-spinner" style="text-align: center; margin: 1rem 0;">
                        <div
                            style="display: inline-block; width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite;">
                        </div>
                        <p style="margin-top: 1rem; color: #667eea;">ü§ñ Initializing Rishi...</p>
                    </div>
                </div>
                <button id="requestPermissions" class="btn btn-primary btn-large">
                    üé§ Enable Camera & Microphone (Optional)
                </button>
                <div id="permissionHelp" class="permission-help" style="display: none; margin-top: 1rem;">
                    <p><strong>Having issues?</strong></p>
                    <ul>
                        <li>Make sure you're using <strong>HTTPS</strong></li>
                        <li>Check for camera/microphone icons in address bar</li>
                        <li>Refresh the page and try again</li>
                    </ul>
                    <button id="testRobotButton" class="btn btn-secondary" style="margin-top: 1rem;"
                        onclick="showRobotForTesting()">
                        ü§ñ Test Robot Animation (Skip Camera)
                    </button>
                </div>
            </div>
        </div>

        <div class="interview-header">
            <h2>Rishi Interview Session</h2>
            <div class="progress-info">
                Question {{ question_num }} of {{ total_questions }}
                <div class="timer-container">
                    <div class="timer-section">
                        <span class="timer-label">Answer Time:</span>
                        <div class="timer" id="answerTimer">30</div>
                    </div>
                </div>
            </div>
            <!-- Manual start button for debugging -->
            <div style="margin-top: 1rem; text-align: center;">
                <button id="manualStartBtn" class="btn btn-primary" style="background: #28a745; display: none;"
                    onclick="showRobotForTesting()">
                    üöÄ Start Interview Manually
                </button>
            </div>
        </div>

        <div class="interview-content">
            <!-- Video Feed -->
            <div class="video-section">
                <div class="video-container">
                    <video id="interviewVideo" autoplay muted playsinline style="display: none;"></video>
                    <!-- Robot Animation - Shows instead of camera feed -->
                    <div id="robotAnimation" class="robot-animation" style="display: none;">
                        <div class="robot-container">
                            <div class="robot-head">
                                <div class="robot-eyes">
                                    <div class="robot-eye left-eye"></div>
                                    <div class="robot-eye right-eye"></div>
                                </div>
                                <div class="robot-mouth"></div>
                            </div>
                            <div class="robot-body">
                                <div class="robot-chest">
                                    <div class="robot-screen">
                                        <div class="screen-content">
                                            <div class="screen-text">RISHI</div>
                                            <div class="screen-pulse"></div>
                                            <!-- AI Avatar with pulsing effect -->
                                            <div class="ai-avatar">
                                                <div class="pulse-ring"></div>
                                                <div class="core"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="robot-arms">
                                    <div class="robot-arm left-arm"></div>
                                    <div class="robot-arm right-arm"></div>
                                </div>
                            </div>
                            <div class="robot-base">
                                <div class="robot-legs">
                                    <div class="robot-leg left-leg"></div>
                                    <div class="robot-leg right-leg"></div>
                                </div>
                            </div>
                        </div>
                        <div class="robot-glow"></div>
                    </div>
                    <div id="cameraPlaceholder" class="camera-placeholder">
                        <div class="placeholder-content">
                            <div class="placeholder-icon">ü§ñ</div>
                            <p>AI Interviewer will appear here</p>
                            <button id="enableCamera" class="btn btn-primary">Start Interview</button>
                        </div>
                    </div>
                    <div class="video-overlay">
                        <div class="status-indicator" id="statusIndicator">
                            <span class="status-dot"></span>
                            <span id="statusText">Click "Start Interview" to begin</span>
                        </div>
                        <!-- Physical Analysis Indicators with Animations -->
                        <div id="physicalAnalysisIndicator"
                            style="display: none; position: absolute; top: 50px; left: 15px; background: rgba(102, 126, 234, 0.95); backdrop-filter: blur(10px); color: white; padding: 15px 20px; border-radius: 25px; font-size: 13px; font-weight: 600; box-shadow: 0 8px 25px rgba(0,0,0,0.3); z-index: 100; min-width: 200px;">
                            <div
                                style="font-size: 14px; font-weight: 700; margin-bottom: 10px; text-align: center; border-bottom: 2px solid rgba(255,255,255,0.3); padding-bottom: 8px;">
                                üìä Live Analysis</div>
                            <div id="confidenceScore" class="analysis-item">
                                <span class="analysis-label">Confidence:</span>
                                <span class="analysis-value" id="confidenceValue">--</span>
                                <div class="analysis-bar">
                                    <div class="analysis-bar-fill" id="confidenceBar" style="width: 0%;"></div>
                                </div>
                            </div>
                            <div id="voiceScore" class="analysis-item">
                                <span class="analysis-label">Voice:</span>
                                <span class="analysis-value" id="voiceValue">--</span>
                                <div class="analysis-bar">
                                    <div class="analysis-bar-fill" id="voiceBar" style="width: 0%;"></div>
                                </div>
                            </div>
                            <div id="bodyLanguageScore" class="analysis-item">
                                <span class="analysis-label">Body Language:</span>
                                <span class="analysis-value" id="bodyLanguageValue">--</span>
                                <div class="analysis-bar">
                                    <div class="analysis-bar-fill" id="bodyLanguageBar" style="width: 0%;"></div>
                                </div>
                            </div>
                            <div id="physicalScore" class="analysis-item"
                                style="margin-top: 10px; padding-top: 10px; border-top: 2px solid rgba(255,255,255,0.3); font-weight: 700;">
                                <span class="analysis-label">Overall Score:</span>
                                <span class="analysis-value" id="physicalScoreValue" style="font-size: 16px;">--</span>
                                <div class="analysis-bar">
                                    <div class="analysis-bar-fill" id="physicalScoreBar"
                                        style="width: 0%; background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="ai-speaking-indicator" id="aiSpeakingIndicator" style="display: none;">
                            <div class="ai-avatar">ü§ñ</div>
                            <div class="ai-speech-bubble" id="aiSpeechBubble">
                                <p id="aiQuestionText">{{ question.question if question else "Loading question..." }}
                                </p>
                            </div>
                        </div>
                        <div class="recording-indicator" id="recordingIndicator" style="display: none;">
                            <span class="recording-dot"></span>
                            You are Speaking
                        </div>
                    </div>
                </div>
            </div>

            <!-- Question Section -->
            <div class="question-section">
                <!-- Chatbot Button - Shows answer section when clicked -->
                <div class="chatbot-button-container" id="chatbotButtonContainer" style="display: block;">
                    <button id="chatbotButton" class="btn btn-primary btn-large chatbot-btn">
                        üí¨ Open Chatbot to Respond
                    </button>
                </div>

                <!-- Answer Section - Hidden by default, shown when chatbot button is clicked -->
                <div class="answer-section" id="answerSection" style="display: none;">
                    <div class="answer-section-header">
                        <h4>üí¨ Your Response</h4>
                        <button type="button" id="closeAnswerSection" class="btn btn-small btn-secondary">‚úï
                            Close</button>
                    </div>
                    <form id="answerForm">
                        <div class="form-group">
                            <label for="answer">Your Response:</label>
                            <textarea id="answer" name="answer" rows="6"
                                placeholder="Rishi has asked you a question. Please respond by typing or using voice..."
                                required></textarea>
                        </div>

                        <!-- Voice Input Section -->
                        <div class="voice-section">
                            <div class="voice-controls">
                                <button type="button" id="voiceButton" class="btn btn-voice">
                                    üé§ Speak Your Answer
                                </button>
                                <button type="button" id="stopVoiceButton" class="btn btn-secondary"
                                    style="display: none;">
                                    ‚èπÔ∏è Stop Speaking
                                </button>
                            </div>
                            <div id="voiceStatus" class="voice-status">
                                Click the microphone to speak your response
                            </div>
                            <div id="voicePreview" class="voice-preview"></div>

                            <!-- Audio Visualizer -->
                            <div class="audio-visualizer">
                                <canvas id="visualizer" width="300" height="50" style="display: none;"></canvas>
                            </div>
                        </div>

                        <div class="action-buttons">
                            <button type="submit" class="btn btn-primary">Submit Response</button>
                            <button type="button" id="skipButton" class="btn btn-secondary">Skip Question</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <!-- Feedback Section -->
        <div id="feedbackSection" class="feedback-section" style="display: none;">
            <h4>Rishi Feedback:</h4>
            <div id="feedbackContent"></div>
            <div class="auto-next-countdown">
                Next question in: <span id="nextCountdown">5</span> seconds
            </div>
            <button id="nextQuestionBtn" class="btn btn-primary">Next Question Now</button>
        </div>
    </div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="loading-spinner"></div>
    <p>Rishi is analyzing your response...</p>
</div>

<script src="{{ {% static 'core/js/voice-recognition.js' %}"></script>
<script>
    // Text-to-Speech Handler - Enhanced Version
    class TextToSpeech {
        constructor() {
            this.synthesis = window.speechSynthesis;
            this.isMuted = false;
            this.currentUtterance = null;
            this.selectedVoice = null;
            this.voicesLoaded = false;
            console.log('üéµ TTS initialized');

            // Load voices (may need to wait)
            this.loadVoices();

            // Some browsers load voices asynchronously
            if (this.synthesis.onvoiceschanged !== undefined) {
                this.synthesis.onvoiceschanged = () => {
                    this.loadVoices();
                };
            }
        }

        loadVoices() {
            const voices = this.synthesis.getVoices();
            console.log(`üì¢ Loaded ${voices.length} voices`);

            // Prefer high-quality English voices
            const preferredVoices = [
                'Google UK English Female',
                'Microsoft Zira - English (United States)',
                'Samantha',
                'Karen',
                'Alex',
                'Google US English'
            ];

            // Try to find preferred voice
            for (const preferredName of preferredVoices) {
                const voice = voices.find(v => v.name.includes(preferredName));
                if (voice && voice.lang.startsWith('en')) {
                    this.selectedVoice = voice;
                    console.log(`‚úÖ Selected voice: ${voice.name}`);
                    this.voicesLoaded = true;
                    return;
                }
            }

            // Fallback to any English voice
            const englishVoice = voices.find(voice =>
                voice.lang.startsWith('en') && voice.localService === true
            ) || voices.find(voice => voice.lang.startsWith('en'));

            if (englishVoice) {
                this.selectedVoice = englishVoice;
                console.log(`‚úÖ Selected fallback voice: ${englishVoice.name}`);
            }

            this.voicesLoaded = true;
        }

        speakQuestion(text) {
            return new Promise((resolve, reject) => {
                if (this.isMuted) {
                    console.log('üîá TTS muted, skipping speech');
                    resolve();
                    return;
                }

                // Wait for voices to load if not ready
                if (!this.voicesLoaded) {
                    setTimeout(() => {
                        this.speakQuestion(text).then(resolve).catch(reject);
                    }, 100);
                    return;
                }

                // Stop any current speech
                this.stop();

                // Clean text - remove extra spaces and format
                const cleanText = text.replace(/\s+/g, ' ').trim();

                // Create new utterance
                this.currentUtterance = new SpeechSynthesisUtterance(cleanText);

                // Configure voice with better settings
                if (this.selectedVoice) {
                    this.currentUtterance.voice = this.selectedVoice;
                }

                // Optimized speech settings for clarity
                this.currentUtterance.rate = 0.85;  // Slightly slower for clarity
                this.currentUtterance.pitch = 1.1;   // Slightly higher pitch (more pleasant)
                this.currentUtterance.volume = 1.0;  // Full volume
                this.currentUtterance.lang = 'en-US'; // Explicit language

                // Event handlers with better error handling
                this.currentUtterance.onstart = () => {
                    console.log('üó£Ô∏è TTS started speaking:', cleanText.substring(0, 50) + '...');
                    // Show speaking indicator
                    const indicator = document.getElementById('aiSpeakingIndicator');
                    if (indicator) {
                        indicator.style.display = 'flex';
                    }
                };

                this.currentUtterance.onend = () => {
                    console.log('‚úÖ TTS finished speaking');
                    this.currentUtterance = null;
                    // Hide speaking indicator
                    const indicator = document.getElementById('aiSpeakingIndicator');
                    if (indicator) {
                        // Keep it visible briefly, then hide
                        setTimeout(() => {
                            if (indicator) indicator.style.display = 'none';
                        }, 500);
                    }
                    // Remove robot speaking animation
                    const robotAnimation = document.getElementById('robotAnimation');
                    if (robotAnimation) {
                        robotAnimation.classList.remove('robot-speaking');
                    }
                    resolve();
                };

                this.currentUtterance.onerror = (event) => {
                    console.error('‚ùå TTS error:', event.error, event);
                    this.currentUtterance = null;

                    // Try fallback: speak without voice selection
                    if (event.error !== 'interrupted') {
                        console.log('üîÑ Trying fallback TTS...');
                        const fallbackUtterance = new SpeechSynthesisUtterance(cleanText);
                        fallbackUtterance.rate = 0.85;
                        fallbackUtterance.pitch = 1.0;
                        fallbackUtterance.volume = 1.0;
                        fallbackUtterance.onend = () => resolve();
                        fallbackUtterance.onerror = () => {
                            console.error('‚ùå Fallback TTS also failed');
                            resolve(); // Resolve anyway to continue interview
                        };
                        this.synthesis.speak(fallbackUtterance);
                    } else {
                        resolve(); // Interrupted is not a real error
                    }
                };

                // Start speaking with a small delay to ensure synthesis is ready
                setTimeout(() => {
                    try {
                        // Check if synthesis is available
                        if (!this.synthesis) {
                            console.error('‚ùå Speech synthesis not available');
                            resolve();
                            return;
                        }

                        // Cancel any pending speech
                        if (this.synthesis.speaking) {
                            this.synthesis.cancel();
                            // Wait a bit before starting new speech
                            setTimeout(() => {
                                this.synthesis.speak(this.currentUtterance);
                                console.log('üó£Ô∏è TTS started speaking (after cancel)');
                            }, 100);
                        } else {
                            this.synthesis.speak(this.currentUtterance);
                            console.log('üó£Ô∏è TTS started speaking');
                        }
                    } catch (error) {
                        console.error('‚ùå Error starting TTS:', error);
                        resolve(); // Continue even if TTS fails
                    }
                }, 200); // Increased delay for better reliability
            });
        }

        stop() {
            if (this.synthesis.speaking) {
                this.synthesis.cancel();
                console.log('‚èπÔ∏è TTS stopped');
            }
            this.currentUtterance = null;
        }

        toggleMute() {
            this.isMuted = !this.isMuted;
            console.log('üîá TTS muted:', this.isMuted);
            if (this.isMuted) {
                this.stop();
            }
            return this.isMuted;
        }
    }

    // Physical Analysis Manager
    class PhysicalAnalysisManager {
        constructor() {
            this.videoFrames = [];
            this.audioSegments = [];
            this.frameInterval = null;
            this.audioInterval = null;
            this.canvas = null;
            this.ctx = null;
            this.audioContext = null;
            this.analyser = null;
            this.mediaStream = null;
            this.analysisInterval = 2000; // Analyze every 2 seconds
            this.isCollecting = false;
        }

        initialize(videoElement, mediaStream) {
            this.mediaStream = mediaStream;
            this.videoElement = videoElement;

            // Create canvas for video frame capture
            this.canvas = document.createElement('canvas');
            this.canvas.width = videoElement.videoWidth || 640;
            this.canvas.height = videoElement.videoHeight || 480;
            this.ctx = this.canvas.getContext('2d');

            // Setup audio analysis
            try {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.analyser = this.audioContext.createAnalyser();
                const audioTracks = mediaStream.getAudioTracks();
                if (audioTracks.length > 0) {
                    const source = this.audioContext.createMediaStreamSource(mediaStream);
                    source.connect(this.analyser);
                    this.analyser.fftSize = 256;
                }
            } catch (e) {
                console.warn('Audio context not available:', e);
            }

            console.log('‚úÖ Physical analysis manager initialized');
        }

        startCollecting() {
            if (this.isCollecting) return;

            this.isCollecting = true;
            this.videoFrames = [];
            this.audioSegments = [];

            // Capture video frames periodically
            this.frameInterval = setInterval(() => {
                this.captureVideoFrame();
            }, this.analysisInterval);

            // Capture audio segments periodically
            if (this.analyser) {
                this.audioInterval = setInterval(() => {
                    this.captureAudioSegment();
                }, this.analysisInterval);
            }

            console.log('üé• Started collecting physical analysis data');
        }

        stopCollecting() {
            this.isCollecting = false;

            if (this.frameInterval) {
                clearInterval(this.frameInterval);
                this.frameInterval = null;
            }

            if (this.audioInterval) {
                clearInterval(this.audioInterval);
                this.audioInterval = null;
            }

            console.log('üõë Stopped collecting physical analysis data');
        }

        captureVideoFrame() {
            if (!this.videoElement || !this.ctx) return;

            try {
                // Draw video frame to canvas
                this.canvas.width = this.videoElement.videoWidth || 640;
                this.canvas.height = this.videoElement.videoHeight || 480;
                this.ctx.drawImage(this.videoElement, 0, 0, this.canvas.width, this.canvas.height);

                // Convert canvas to base64
                const frameData = this.canvas.toDataURL('image/jpeg', 0.8).split(',')[1]; // Remove data:image/jpeg;base64, prefix

                // Send to server for analysis
                this.sendPhysicalData(frameData, null);

            } catch (e) {
                console.error('Error capturing video frame:', e);
            }
        }

        captureAudioSegment() {
            if (!this.analyser) return;

            try {
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                this.analyser.getByteFrequencyData(dataArray);

                // Convert audio data to base64
                const audioData = btoa(String.fromCharCode.apply(null, dataArray));

                // Send to server for analysis
                this.sendPhysicalData(null, audioData);

            } catch (e) {
                console.error('Error capturing audio segment:', e);
            }
        }

        async sendPhysicalData(videoFrame, audioSegment) {
            try {
                const formData = new FormData();
                if (videoFrame) {
                    formData.append('video_frame', videoFrame);
                }
                if (audioSegment) {
                    formData.append('audio_segment', audioSegment);
                }

                // Send to server for real-time analysis
                const response = await fetch('/update_physical_analysis', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.summary) {
                        // Update UI with physical analysis results
                        this.updatePhysicalAnalysisUI(data.summary);
                    }
                }
            } catch (e) {
                console.error('Error sending physical data:', e);
            }
        }

        updatePhysicalAnalysisUI(summary) {
            // Update UI elements with animated physical analysis scores
            const confidenceValue = document.getElementById('confidenceValue');
            const confidenceBar = document.getElementById('confidenceBar');
            const voiceValue = document.getElementById('voiceValue');
            const voiceBar = document.getElementById('voiceBar');
            const bodyLanguageValue = document.getElementById('bodyLanguageValue');
            const bodyLanguageBar = document.getElementById('bodyLanguageBar');
            const physicalScoreValue = document.getElementById('physicalScoreValue');
            const physicalScoreBar = document.getElementById('physicalScoreBar');

            // Animate confidence score
            if (confidenceValue && summary.confidence !== undefined) {
                const score = summary.confidence;
                confidenceValue.textContent = `${score.toFixed(1)}/10`;
                if (confidenceBar) {
                    confidenceBar.style.width = `${(score / 10) * 100}%`;
                    confidenceBar.style.transition = 'width 0.5s ease-out';
                }
                // Add pulse animation for high scores
                confidenceValue.classList.remove('score-high', 'score-medium', 'score-low');
                if (score >= 7) {
                    confidenceValue.classList.add('score-high');
                } else if (score >= 5) {
                    confidenceValue.classList.add('score-medium');
                } else {
                    confidenceValue.classList.add('score-low');
                }
            }

            // Animate voice score
            if (voiceValue && summary.voice_quality !== undefined) {
                const score = summary.voice_quality;
                voiceValue.textContent = `${score.toFixed(1)}/10`;
                if (voiceBar) {
                    voiceBar.style.width = `${(score / 10) * 100}%`;
                    voiceBar.style.transition = 'width 0.5s ease-out';
                }
                voiceValue.classList.remove('score-high', 'score-medium', 'score-low');
                if (score >= 7) {
                    voiceValue.classList.add('score-high');
                } else if (score >= 5) {
                    voiceValue.classList.add('score-medium');
                } else {
                    voiceValue.classList.add('score-low');
                }
            }

            // Animate body language score
            if (bodyLanguageValue && summary.body_language !== undefined) {
                const score = summary.body_language;
                bodyLanguageValue.textContent = `${score.toFixed(1)}/10`;
                if (bodyLanguageBar) {
                    bodyLanguageBar.style.width = `${(score / 10) * 100}%`;
                    bodyLanguageBar.style.transition = 'width 0.5s ease-out';
                }
                bodyLanguageValue.classList.remove('score-high', 'score-medium', 'score-low');
                if (score >= 7) {
                    bodyLanguageValue.classList.add('score-high');
                } else if (score >= 5) {
                    bodyLanguageValue.classList.add('score-medium');
                } else {
                    bodyLanguageValue.classList.add('score-low');
                }
            }

            // Animate overall physical score
            if (physicalScoreValue && summary.overall_physical_score !== undefined) {
                const score = summary.overall_physical_score;
                physicalScoreValue.textContent = `${score.toFixed(1)}/10`;
                if (physicalScoreBar) {
                    physicalScoreBar.style.width = `${(score / 10) * 100}%`;
                    physicalScoreBar.style.transition = 'width 0.5s ease-out';
                }
                // Add pulse animation for overall score
                physicalScoreValue.classList.remove('score-high', 'score-medium', 'score-low');
                if (score >= 7) {
                    physicalScoreValue.classList.add('score-high');
                } else if (score >= 5) {
                    physicalScoreValue.classList.add('score-medium');
                } else {
                    physicalScoreValue.classList.add('score-low');
                }
            }
        }

        async sendFinalAnalysis() {
            // Send all collected data for final analysis
            try {
                const formData = new FormData();
                this.videoFrames.forEach((frame, index) => {
                    formData.append('video_frames[]', frame);
                });
                this.audioSegments.forEach((segment, index) => {
                    formData.append('audio_segments[]', segment);
                });

                const response = await fetch('/analyze_physical', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ Physical analysis completed:', data.summary);
                    return data.analysis;
                }
            } catch (e) {
                console.error('Error sending final physical analysis:', e);
            }
            return null;
        }
    }

    // Interview State Management
    class InterviewTimer {
        constructor(duration, displayElement) {
            // Support both parameter styles for compatibility
            this.listeningTime = 0; // No thinking time - go directly to answering
            this.answerTime = duration || 30; // Use parameter or default to 30
            this.display = displayElement; // Store display element if provided
            this.remaining = duration || 30; // For compatibility with script.js
            this.listeningTimer = null;
            this.answerTimer = null;
            this.nextCountdownTimer = null;
            this.currentState = 'waiting_permissions';
            this.permissionsGranted = false;
            this.mediaStream = null; // Store media stream for cleanup
            this.physicalAnalyzer = new PhysicalAnalysisManager(); // Physical analysis manager
        }

        // Stop all media streams (camera and microphone)
        stopAllMedia() {
            console.log('üõë Stopping all media streams...');

            // Stop video stream tracks
            if (this.mediaStream) {
                this.mediaStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('‚úÖ Stopped track:', track.kind);
                });
                this.mediaStream = null;
            }

            // Stop video element
            const videoElement = document.getElementById('interviewVideo');
            if (videoElement && videoElement.srcObject) {
                const stream = videoElement.srcObject;
                stream.getTracks().forEach(track => {
                    track.stop();
                    console.log('‚úÖ Stopped video track:', track.kind);
                });
                videoElement.srcObject = null;
            }

            // Stop voice recognition media stream
            if (typeof voiceRecognition !== 'undefined' && voiceRecognition.mediaStream) {
                voiceRecognition.mediaStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('‚úÖ Stopped voice recognition track:', track.kind);
                });
                voiceRecognition.mediaStream = null;
            }

            // Stop audio context
            if (typeof voiceRecognition !== 'undefined' && voiceRecognition.audioContext) {
                voiceRecognition.audioContext.close().then(() => {
                    console.log('‚úÖ Audio context closed');
                }).catch(err => {
                    console.error('Error closing audio context:', err);
                });
            }
        }

        async requestPermissions() {
            // Check OTP verification first
            const otpVerified = sessionStorage.getItem('otpVerified') === 'true';
            if (!otpVerified) {
                alert('Please verify OTP first before starting the interview.');
                return;
            }

            try {
                console.log('üîê Requesting camera and microphone permissions...');
                // Try to enter fullscreen (requires user gesture; will work when button is clicked)
                try {
                    if (document.documentElement.requestFullscreen) {
                        await document.documentElement.requestFullscreen();
                        console.log('üñ•Ô∏è Fullscreen enabled');
                    }
                } catch (e) {
                    console.log('‚ÑπÔ∏è Fullscreen not enabled (browser blocked or not requested via gesture)');
                }

                // Show loading state
                document.getElementById('statusText').textContent = 'Requesting permissions...';
                document.getElementById('requestPermissions').disabled = true;
                document.getElementById('requestPermissions').textContent = 'Requesting...';

                // Request camera and microphone permissions with persistent constraints
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 1280,
                        height: 720,
                        facingMode: 'user'
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                console.log('‚úÖ Permissions granted successfully!');

                // Store stream for cleanup (but don't stop it during interview!)
                this.mediaStream = stream;

                // Monitor stream health - restart if it stops unexpectedly
                stream.getVideoTracks().forEach(track => {
                    track.onended = () => {
                        console.warn('‚ö†Ô∏è Video track ended unexpectedly');
                        if (this.currentState !== 'completed') {
                            console.log('üîÑ Attempting to restore video stream...');
                            // Don't auto-restart, let user know
                            document.getElementById('statusText').textContent = 'Camera disconnected. Please refresh.';
                        }
                    };
                });

                stream.getAudioTracks().forEach(track => {
                    track.onended = () => {
                        console.warn('‚ö†Ô∏è Audio track ended unexpectedly');
                        if (this.currentState !== 'completed') {
                            console.log('üîÑ Attempting to restore audio stream...');
                            document.getElementById('statusText').textContent = 'Microphone disconnected. Please refresh.';
                        }
                    };
                });

                // Permissions granted - store in sessionStorage
                sessionStorage.setItem('cameraMicPermissions', 'true');
                this.permissionsGranted = true;

                // Show robot animation instead of video feed, hide placeholder and permission warning
                document.getElementById('interviewVideo').srcObject = stream;
                document.getElementById('interviewVideo').style.display = 'none'; // Keep video hidden from user
                document.getElementById('robotAnimation').style.display = 'flex'; // Show robot animation
                document.getElementById('cameraPlaceholder').style.display = 'none';
                document.getElementById('permissionWarning').style.display = 'none';

                console.log('üé≠ Robot animation should now be visible!');
                console.log('ü§ñ Robot element:', document.getElementById('robotAnimation'));
                console.log('ü§ñ Robot display style:', document.getElementById('robotAnimation').style.display);

                // Initialize voice recognition with the stream
                if (typeof voiceRecognition !== 'undefined') {
                    voiceRecognition.initialize(stream);
                    // Store stream reference in voiceRecognition for cleanup
                    voiceRecognition.mediaStream = stream;
                }

                // Initialize physical analysis manager
                const videoElement = document.getElementById('interviewVideo');
                if (videoElement) {
                    this.physicalAnalyzer.initialize(videoElement, stream);
                    // Start physical analysis immediately when camera is on
                    this.physicalAnalyzer.startCollecting();
                    // Show physical analysis indicator with animations
                    const indicator = document.getElementById('physicalAnalysisIndicator');
                    if (indicator) {
                        indicator.style.display = 'block';
                        indicator.classList.add('animate-in');
                    }
                    console.log('‚úÖ Physical analysis started immediately - camera is checking confidence/behavior');
                }

                // Buttons enabled (mute button removed)

                // Update status
                document.getElementById('statusText').textContent = 'Permissions granted! Starting interview...';
                document.getElementById('timeInfo').textContent = 'Rishi will ask the first question shortly';

                // Show AI speaking indicator
                document.getElementById('aiSpeakingIndicator').style.display = 'flex';

                // Make robot more animated when speaking
                const robotAnimation = document.getElementById('robotAnimation');
                if (robotAnimation) {
                    robotAnimation.classList.add('robot-speaking');
                }

                // Start the interview after a brief delay
                // Ensure camera and microphone are fully enabled before starting
                setTimeout(() => {
                    // Double-check permissions are still active
                    if (stream && stream.active) {
                        console.log('‚úÖ Stream is active - starting interview');
                        this.startAISpeakingPhase();
                    } else {
                        console.warn('‚ö†Ô∏è Stream not active - requesting again');
                        this.requestPermissions();
                    }
                }, 2000);

            } catch (error) {
                console.error('‚ùå Permission error:', error);
                this.handlePermissionError(error);

                // Reset button state
                document.getElementById('requestPermissions').disabled = false;
                document.getElementById('requestPermissions').textContent = 'üé§ Start Interview & Enable Camera';
            }
        }

        handlePermissionError(error) {
            // Show robot animation as fallback for testing even if camera fails
            document.getElementById('robotAnimation').style.display = 'flex';
            document.getElementById('cameraPlaceholder').style.display = 'none';
            console.log('ü§ñ Showing robot animation as fallback after permission error');

            // Set permissions as granted for robot mode
            this.permissionsGranted = true;
            sessionStorage.setItem('cameraMicPermissions', 'robot-mode');

            // Still show the warning but allow interview to proceed
            document.getElementById('permissionWarning').style.display = 'block';
            document.getElementById('permissionHelp').style.display = 'block';

            const statusText = document.getElementById('statusText');
            const timeInfo = document.getElementById('timeInfo');

            if (error.name === 'NotAllowedError') {
                statusText.textContent = 'Permissions denied - Robot mode active';
                timeInfo.textContent = 'Interview will proceed with robot avatar (camera optional)';
            } else if (error.name === 'NotFoundError') {
                statusText.textContent = 'No camera/microphone found - Robot mode active';
                timeInfo.textContent = 'Interview will proceed with robot avatar';
            } else if (error.name === 'NotSupportedError') {
                statusText.textContent = 'Browser not supported - Robot mode active';
                timeInfo.textContent = 'Interview will proceed with robot avatar';
            } else {
                statusText.textContent = 'Permission error - Robot mode active';
                timeInfo.textContent = 'Interview will proceed with robot avatar: ' + error.message;
            }

            // Start interview even without camera permissions
            setTimeout(() => {
                this.startAISpeakingPhase();
            }, 2000);
        }

        startAISpeakingPhase() {
            console.log('üéØ startAISpeakingPhase called');
            if (!this.permissionsGranted) {
                console.warn('‚ö†Ô∏è Permissions not granted, cannot start speaking');
                return;
            }

            console.log('‚úÖ Permissions granted, proceeding with AI speaking');
            this.currentState = 'ai_speaking';
            const statusText = document.getElementById('statusText');
            const timeInfo = document.getElementById('timeInfo');
            const listeningTimerElement = document.getElementById('listeningTimer');
            const aiSpeakingIndicator = document.getElementById('aiSpeakingIndicator');

            // Update UI for AI speaking phase
            statusText.textContent = 'Rishi is Speaking';
            timeInfo.textContent = 'Listen carefully to the question...';
            listeningTimerElement.textContent = this.listeningTime;
            listeningTimerElement.className = 'timer ai-speaking';

            // Show AI speaking indicator
            if (aiSpeakingIndicator) {
                aiSpeakingIndicator.style.display = 'flex';
            }

            // Get question text - ensure we have the question
            let questionText = '';
            const questionTextElement = document.getElementById('questionText');
            if (questionTextElement) {
                questionText = questionTextElement.textContent || questionTextElement.innerText;
            }

            // Fallback: try to get from question card
            if (!questionText) {
                const questionCard = document.getElementById('questionCard');
                if (questionCard) {
                    const h3 = questionCard.querySelector('h3');
                    if (h3) {
                        questionText = h3.textContent || h3.innerText;
                    }
                }
            }

            if (!questionText) {
                console.error('‚ùå Could not find question text');
                // Continue anyway
                setTimeout(() => this.startListeningPhase(), 1000);
                return;
            }

            const questionNumber = this.getCurrentQuestionNumber();
            const fullQuestion = `Question ${questionNumber}. ${questionText}`;

            console.log('üó£Ô∏è Rishi will speak:', fullQuestion);

            // Ensure TTS is ready
            if (typeof textToSpeech === 'undefined') {
                console.error('‚ùå TTS not available');
                setTimeout(() => this.startListeningPhase(), 2000);
                return;
            }

            // Check if speech synthesis is supported
            if (!('speechSynthesis' in window)) {
                console.error('‚ùå Speech synthesis not supported in this browser');
                setTimeout(() => this.startListeningPhase(), 2000);
                return;
            }

            console.log('üé§ Calling textToSpeech.speakQuestion...');
            // Rishi speaks the question using TTS with retry logic
            textToSpeech.speakQuestion(fullQuestion)
                .then(() => {
                    console.log('‚úÖ Rishi finished speaking question');
                    // No thinking time - go directly to answering phase and auto-start microphone
                    setTimeout(() => {
                        this.startAnsweringPhase();
                        // Auto-start microphone immediately
                        this.autoStartMicrophone();
                    }, 300);
                })
                .catch(error => {
                    console.error('‚ùå TTS error, continuing without speech:', error);
                    // Even if TTS fails, go directly to answering
                    setTimeout(() => {
                        this.startAnsweringPhase();
                        // Auto-start microphone immediately
                        this.autoStartMicrophone();
                    }, 500);
                });
        }

        startAnsweringPhase() {
            console.log('üéØ startAnsweringPhase called, answerTime:', this.answerTime);
            this.currentState = 'answering';
            this.remaining = this.answerTime; // Initialize remaining time
            console.log('‚è∞ Timer initialized with remaining:', this.remaining);
            const listeningTimerElement = document.getElementById('listeningTimer');
            const answerTimerElement = document.getElementById('answerTimer');
            const statusText = document.getElementById('statusText');
            const timeInfo = document.getElementById('timeInfo');
            const answerSection = document.getElementById('answerSection');
            const questionCard = document.getElementById('questionCard');
            const chatbotButtonContainer = document.getElementById('chatbotButtonContainer');

            // Hide behavioral questions
            const questionType = questionCard ? questionCard.querySelector('.question-type')?.textContent.toLowerCase() : '';
            if (questionType && 'behavioral' in questionType) {
                if (questionCard) questionCard.style.display = 'none';
            }

            // Show chatbot button instead of answer section directly
            if (chatbotButtonContainer) {
                chatbotButtonContainer.style.display = 'block';
            }
            // Keep answer section hidden until chatbot button is clicked
            if (answerSection) {
                answerSection.style.display = 'none';
            }

            if (questionCard) {
                questionCard.classList.add('minimized');
            }

            // Ensure microphone is still active if it was auto-started
            if (this.permissionsGranted && typeof voiceRecognition !== 'undefined') {
                // Microphone should already be running from autoStartMicrophone
                // But ensure it's active
                try {
                    if (!voiceRecognition.isListening) {
                        voiceRecognition.startListening();
                        updateVoiceUI('listening');
                        console.log('‚úÖ Microphone started in answering phase');
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Could not ensure microphone is active:', error);
                }
            }

            // Start collecting physical analysis data immediately
            if (this.physicalAnalyzer && this.permissionsGranted) {
                this.physicalAnalyzer.startCollecting();
                // Show physical analysis indicator with animations
                const indicator = document.getElementById('physicalAnalysisIndicator');
                if (indicator) {
                    indicator.style.display = 'block';
                    indicator.classList.add('animate-in');
                }
                console.log('‚úÖ Physical analysis active - showing animated indicators');
            }

            // Update UI for answering phase
            listeningTimerElement.className = 'timer completed';
            answerTimerElement.className = 'timer active';
            statusText.textContent = 'Answer the Question';
            timeInfo.textContent = `Respond now: ${this.remaining} seconds remaining`;

            this.answerTimer = setInterval(() => {
                console.log('‚è∞ Timer tick, remaining before:', this.remaining);
                this.remaining--;
                console.log('‚è∞ Timer tick, remaining after:', this.remaining);
                answerTimerElement.textContent = this.remaining;

                // Show warning when 5 seconds remaining (for 30-second timer)
                if (this.remaining <= 5) {
                    answerTimerElement.classList.add('warning');
                }

                if (this.remaining <= 0) {
                    console.log('‚è∞ Timer reached 0, submitting answer');
                    clearInterval(this.answerTimer);
                    this.submitAnswer();
                }
            }, 1000);
        }

        async submitAnswer() {
            // Stop collecting physical data
            if (this.physicalAnalyzer) {
                this.physicalAnalyzer.stopCollecting();
                // Send final analysis
                await this.physicalAnalyzer.sendFinalAnalysis();
            }

            const answer = document.getElementById('answer').value;
            if (!answer.trim()) {
                document.getElementById('answer').value = '[No response provided]';
            }
            // Trigger form submission
            document.getElementById('answerForm').dispatchEvent(new Event('submit'));
        }

        startNextCountdown(seconds = 5) {
            this.currentState = 'feedback';
            let timeLeft = seconds;
            const countdownElement = document.getElementById('nextCountdown');
            const nextButton = document.getElementById('nextQuestionBtn');

            countdownElement.textContent = timeLeft;

            this.nextCountdownTimer = setInterval(() => {
                timeLeft--;
                countdownElement.textContent = timeLeft;

                if (timeLeft <= 0) {
                    clearInterval(this.nextCountdownTimer);
                    this.goToNextQuestion();
                }
            }, 1000);

            nextButton.onclick = () => {
                clearInterval(this.nextCountdownTimer);
                this.loadNextQuestion();
            };
        }

        async loadNextQuestion() {
            // IMPORTANT: do NOT stop camera/mic between questions.
            // We keep the same media stream and just fetch the next question.
            try {
                // Stop timers and TTS, but keep media running
                this.stopAllTimers();
                if (typeof textToSpeech !== 'undefined') {
                    textToSpeech.stop();
                }

                // Hide feedback UI
                const feedbackSection = document.getElementById('feedbackSection');
                if (feedbackSection) feedbackSection.style.display = 'none';

                // Clear answer UI and reset chatbot button
                const answerTextarea = document.getElementById('answer');
                if (answerTextarea) answerTextarea.value = '';
                const voicePreview = document.getElementById('voicePreview');
                if (voicePreview) voicePreview.textContent = '';

                // Hide answer section, show chatbot button
                const answerSectionEl = document.getElementById('answerSection');
                const chatbotButtonContainerEl = document.getElementById('chatbotButtonContainer');
                if (answerSectionEl) answerSectionEl.style.display = 'none';
                if (chatbotButtonContainerEl) chatbotButtonContainerEl.style.display = 'block';

                // Fetch next question from server (also triggers sequential HF generation server-side)
                const res = await fetch('/get_next_question');
                if (!res.ok) throw new Error('Failed to fetch next question: ' + res.status);
                const data = await res.json();

                if (data.completed) {
                    console.log('‚úÖ Interview completed - redirecting to results');
                    this.stopEverything();
                    window.location.href = '/results';
                    return;
                }

                // Update question text in BOTH places
                const questionTextEl = document.getElementById('questionText');
                if (questionTextEl) questionTextEl.textContent = data.question || '';
                const aiQuestionTextEl = document.getElementById('aiQuestionText');
                if (aiQuestionTextEl) aiQuestionTextEl.textContent = data.question || '';

                // Update meta (type) and hide if behavioral
                const typeEl = document.querySelector('.question-type');
                const questionCard = document.getElementById('questionCard');
                const questionType = (data.type || 'technical').toString().toLowerCase();

                if (typeEl) {
                    typeEl.textContent = `${questionType.charAt(0).toUpperCase()}${questionType.slice(1)} Question`;
                }

                // Hide behavioral questions
                if (questionCard && questionType === 'behavioral') {
                    questionCard.style.display = 'none';
                } else if (questionCard) {
                    questionCard.style.display = 'block';
                }

                // Reset chatbot button and answer section
                if (chatbotButtonContainerEl) chatbotButtonContainerEl.style.display = 'block';
                if (answerSectionEl) answerSectionEl.style.display = 'none';

                // Update progress text if visible
                const progressInfo = document.querySelector('.progress-info');
                if (progressInfo && data.question_num && data.total_questions) {
                    progressInfo.firstChild.textContent = `Question ${data.question_num} of ${data.total_questions} `;
                }

                // Restart interview flow for the new question
                this.startAISpeakingPhase();
                // Start mic automatically (safe if browser blocks)
                if (typeof this.autoStartMicrophone === 'function') {
                    this.autoStartMicrophone();
                }
            } catch (e) {
                console.error('‚ùå Error loading next question:', e);
                alert('Could not load next question. Please refresh and try again.');
            }
        }

        stopAllTimers() {
            if (this.listeningTimer) clearInterval(this.listeningTimer);
            if (this.answerTimer) clearInterval(this.answerTimer);
            if (this.nextCountdownTimer) clearInterval(this.nextCountdownTimer);
        }

        // Stop everything including media
        stopEverything() {
            console.log('üõë Stopping everything...');
            this.stopAllTimers();
            this.stopAllMedia();

            // Stop physical analysis
            if (this.physicalAnalyzer) {
                this.physicalAnalyzer.stopCollecting();
            }

            // Stop text-to-speech
            if (typeof textToSpeech !== 'undefined') {
                textToSpeech.stop();
            }

            // Stop voice recognition
            if (typeof voiceRecognition !== 'undefined') {
                voiceRecognition.stopListening();
            }

            // Clear permission storage
            sessionStorage.removeItem('cameraMicPermissions');
        }

        getCurrentQuestionNumber() {
            const progressInfo = document.querySelector('.progress-info');
            const text = progressInfo ? progressInfo.textContent : '';
            const match = text.match(/Question (\d+) of/);
            return match ? match[1] : '1';
        }

        // Compatibility method for script.js InterviewTimer
        updateDisplay() {
            if (this.display) {
                const minutes = Math.floor(this.remaining / 60);
                const seconds = this.remaining % 60;
                this.display.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

    }

    // Global instances - Initialize safely after DOM loads
    let interviewTimer = null;
    let textToSpeech = null;

    // Initialize global instances after DOM is ready
    function initializeGlobalInstances() {
        try {
            const answerTimerElement = document.getElementById('answerTimer');
            if (answerTimerElement) {
                interviewTimer = new InterviewTimer(30, answerTimerElement); // Pass parameters for compatibility
                // Make it globally accessible for testing
                window.interviewManager = interviewTimer;
                console.log('‚úÖ InterviewTimer initialized successfully');
            } else {
                console.warn('‚ö†Ô∏è answerTimer element not found during initialization');
                // Create with null display element
                interviewTimer = new InterviewTimer(30, null);
                window.interviewManager = interviewTimer;
            }

            textToSpeech = new TextToSpeech();
            console.log('‚úÖ TextToSpeech initialized successfully');
        } catch (error) {
            console.error('‚ùå Error initializing global instances:', error);
            // Create fallback instances
            interviewTimer = { start: () => { }, stop: () => { } };
            textToSpeech = { speakQuestion: () => Promise.resolve() };
            window.interviewManager = interviewTimer;
        }
    }

    // CSS Fix Function - Ensures styles are applied after navigation
    function applyCSSFixes() {
        // Force reflow to trigger CSS recalculation
        document.body.offsetHeight;

        // Re-apply all critical styles
        const criticalElements = [
            '.interview-room',
            '.video-section',
            '.question-section',
            '.interview-header',
            '.timer',
            '.btn',
            '.feature-card',
            '.question-card',
            '.answer-section',
            '.feedback-section'
        ];

        criticalElements.forEach(selector => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(el => {
                // Force style recalculation
                const computedStyle = window.getComputedStyle(el);
                const display = computedStyle.display;

                // If element should be visible but isn't, fix it
                if (display === 'none' && !el.hasAttribute('data-hidden')) {
                    // Check if parent is hiding it
                    const parentStyle = window.getComputedStyle(el.parentElement);
                    if (parentStyle.display !== 'none') {
                        el.style.display = '';
                        el.style.display = computedStyle.display || 'block';
                    }
                }

                // Ensure classes are applied
                if (!el.className.includes(selector.replace('.', ''))) {
                    el.classList.add(selector.replace('.', ''));
                }
            });
        });

        // Force all stylesheets to be active
        try {
            for (let i = 0; i < document.styleSheets.length; i++) {
                const sheet = document.styleSheets[i];
                if (sheet && sheet.cssRules) {
                    // Access rules to ensure stylesheet is loaded
                    try {
                        const rules = sheet.cssRules;
                        console.log(`‚úÖ Stylesheet ${i} loaded with ${rules.length} rules`);
                    } catch (e) {
                        console.warn(`‚ö†Ô∏è Cannot access stylesheet ${i} (CORS or other issue)`);
                    }
                }
            }
        } catch (e) {
            console.warn('Error accessing stylesheets:', e);
        }

        console.log('‚úÖ CSS fixes applied');
    }

    // Main interview start function
    function startInterview() {
        try {
            console.log('üéØ startInterview() called');

            // Use the fallback method which handles TTS and interview flow
            if (typeof fallbackStartInterview === 'function') {
                fallbackStartInterview();
            } else {
                console.error('‚ùå fallbackStartInterview function not available');
            }
        } catch (error) {
            console.error('‚ùå Error in startInterview:', error);
            // Last resort: try to manually trigger TTS
            console.log('üîÑ Last resort: trying manual TTS...');
            try {
                const questionTextElement = document.getElementById('questionText');
                if (questionTextElement && textToSpeech && typeof textToSpeech.speakQuestion === 'function') {
                    const questionText = questionTextElement.textContent || questionTextElement.innerText;
                    if (questionText) {
                        textToSpeech.speakQuestion(`Question 1. ${questionText}`);
                    }
                }
            } catch (manualError) {
                console.error('‚ùå Manual TTS also failed:', manualError);
            }
        }
    }

    // Test robot animation function (for debugging)
    function showRobotForTesting() {
        try {
            console.log('ü§ñ Manual robot test triggered');

            // Set permissions as granted for robot mode
            if (window.interviewManager) {
                window.interviewManager.permissionsGranted = true;
            }
            sessionStorage.setItem('cameraMicPermissions', 'robot-mode');

            // Show robot animation
            const robotElement = document.getElementById('robotAnimation');
            const placeholderElement = document.getElementById('cameraPlaceholder');
            const warningElement = document.getElementById('permissionWarning');

            if (robotElement) {
                robotElement.style.display = 'flex';
                console.log('ü§ñ Robot animation element found and displayed');
            } else {
                console.error('‚ùå Robot animation element not found!');
                return; // Exit early if robot element doesn't exist
            }

            if (placeholderElement) {
                placeholderElement.style.display = 'none';
            }

            if (warningElement) {
                warningElement.style.display = 'none';
            }

            console.log('ü§ñ Robot animation activated manually');

            // Start the interview
            setTimeout(() => {
                console.log('ü§ñ Starting interview after robot animation...');
                if (typeof startInterview === 'function') {
                    startInterview();
                } else {
                    console.error('‚ùå startInterview function not found');
                }
            }, 1000);
        } catch (error) {
            console.error('‚ùå Error in showRobotForTesting:', error);
            // Fallback: try to start interview directly
            setTimeout(() => {
                if (typeof fallbackStartInterview === 'function') {
                    console.log('üîÑ Fallback: trying fallbackStartInterview...');
                    fallbackStartInterview();
                }
            }, 1000);
        }
    }

    // Fallback function to start interview if main method fails
    function fallbackStartInterview() {
        try {
            console.log('üîÑ Starting interview with fallback method...');

            // Show robot animation
            const robotElement = document.getElementById('robotAnimation');
            if (robotElement) {
                robotElement.style.display = 'flex';
            }

            // Hide other elements
            const placeholderElement = document.getElementById('cameraPlaceholder');
            const warningElement = document.getElementById('permissionWarning');
            if (placeholderElement) placeholderElement.style.display = 'none';
            if (warningElement) warningElement.style.display = 'none';

            // Try to start speaking directly
            setTimeout(() => {
                try {
                    // Get question text
                    const questionTextElement = document.getElementById('questionText');
                    let questionText = '';
                    if (questionTextElement) {
                        questionText = questionTextElement.textContent || questionTextElement.innerText;
                    }

                    if (!questionText) {
                        const questionCard = document.getElementById('questionCard');
                        if (questionCard) {
                            const h3 = questionCard.querySelector('h3');
                            if (h3) {
                                questionText = h3.textContent || h3.innerText;
                            }
                        }
                    }

                    if (questionText && textToSpeech && typeof textToSpeech.speakQuestion === 'function') {
                        const questionNumber = 1; // Assume first question
                        const fullQuestion = `Question ${questionNumber}. ${questionText}`;
                        console.log('üó£Ô∏è Fallback: Rishi speaking:', fullQuestion);

                        textToSpeech.speakQuestion(fullQuestion)
                            .then(() => {
                                console.log('‚úÖ Fallback: Rishi finished speaking');
                                // Start answering phase
                                if (window.interviewManager && window.interviewManager.startAnsweringPhase) {
                                    window.interviewManager.startAnsweringPhase();
                                }
                            })
                            .catch(error => {
                                console.error('‚ùå Fallback TTS error:', error);
                            });
                    } else {
                        console.error('‚ùå Fallback: No question text or TTS not available');
                    }
                } catch (error) {
                    console.error('‚ùå Fallback interview start failed:', error);
                }
            }, 1500);
        } catch (error) {
            console.error('‚ùå Critical error in fallbackStartInterview:', error);
        }
    }

    document.addEventListener('DOMContentLoaded', function () {
        try {
            console.log('üöÄ Interview room DOMContentLoaded triggered');

            // Initialize global instances now that DOM is ready
            initializeGlobalInstances();

            // Check if required elements exist
            const robotElement = document.getElementById('robotAnimation');
            const questionElement = document.getElementById('aiQuestionText');
            const interviewManager = window.interviewManager;

            console.log('üìä Question text:', questionElement ? questionElement.textContent : 'NOT FOUND');
            console.log('ü§ñ Robot element:', robotElement ? 'FOUND' : 'NOT FOUND');
            console.log('üéØ Interview manager:', interviewManager ? 'AVAILABLE' : 'NOT FOUND');

            // Apply CSS fixes immediately
            if (typeof applyCSSFixes === 'function') {
                applyCSSFixes();
            }

            // Apply again after a short delay to ensure DOM is fully ready
            setTimeout(() => {
                if (typeof applyCSSFixes === 'function') {
                    applyCSSFixes();
                }
                document.body.classList.add('loaded');
                console.log('‚úÖ CSS fixes applied (delayed)');
            }, 100);

            // Apply again after stylesheets are fully loaded
            window.addEventListener('load', function () {
                setTimeout(() => {
                    if (typeof applyCSSFixes === 'function') {
                        applyCSSFixes();
                    }
                    console.log('‚úÖ CSS fixes applied (after load)');
                }, 50);
            });

            // Auto-start interview with robot animation (no camera required)
            console.log('ü§ñ Auto-starting interview with robot animation...');
            setTimeout(() => {
                try {
                    console.log('ü§ñ Calling showRobotForTesting()...');
                    showRobotForTesting();
                    console.log('‚úÖ showRobotForTesting() called successfully');
                } catch (error) {
                    console.error('‚ùå Error in auto-start:', error);
                    // Show manual start button as fallback
                    const manualBtn = document.getElementById('manualStartBtn');
                    if (manualBtn) {
                        manualBtn.style.display = 'inline-block';
                        console.log('üîÑ Manual start button shown due to auto-start failure');
                    }
                    // Fallback: try to start interview directly
                    console.log('üîÑ Trying fallback interview start...');
                    if (typeof fallbackStartInterview === 'function') {
                        fallbackStartInterview();
                    }
                }
            }, 1000); // Give page time to fully load

            // Show manual start button after 5 seconds if auto-start didn't work
            setTimeout(() => {
                const robotElement = document.getElementById('robotAnimation');
                if (robotElement && robotElement.style.display !== 'flex') {
                    console.log('‚ö†Ô∏è Robot not visible after 5 seconds, showing manual start button');
                    const manualBtn = document.getElementById('manualStartBtn');
                    if (manualBtn) {
                        manualBtn.style.display = 'inline-block';
                    }
                }
            }, 5000);
        } catch (criticalError) {
            console.error('‚ùå Critical error in DOMContentLoaded:', criticalError);
            // Show emergency manual start button
            setTimeout(() => {
                const manualBtn = document.getElementById('manualStartBtn');
                if (manualBtn) {
                    manualBtn.style.display = 'inline-block';
                    manualBtn.textContent = 'üö® Start Interview (Error Recovery)';
                }
            }, 1000);
        }



        // Request permissions button (optional - for camera access)
        document.getElementById('requestPermissions').addEventListener('click', function () {
            console.log('üéØ Enable Camera & Microphone button clicked');
            interviewTimer.requestPermissions();
        });

        // Enable camera button
        document.getElementById('enableCamera').addEventListener('click', function () {
            console.log('üéØ Enable Camera button clicked');
            interviewTimer.requestPermissions();
        });

        // Voice recognition event listeners
        document.getElementById('voiceButton').addEventListener('click', function () {
            if (!interviewTimer.permissionsGranted) {
                alert('Please start the interview first by clicking "Start Interview"');
                return;
            }
            if (typeof voiceRecognition !== 'undefined') {
                voiceRecognition.startListening();
                updateVoiceUI('listening');
            } else {
                alert('Voice recognition not available');
            }
        });

        document.getElementById('stopVoiceButton').addEventListener('click', function () {
            if (typeof voiceRecognition !== 'undefined') {
                voiceRecognition.stopListening();
                updateVoiceUI('stopped');
            }
        });

        function updateVoiceUI(state) {
            const voiceButton = document.getElementById('voiceButton');
            const stopButton = document.getElementById('stopVoiceButton');
            const status = document.getElementById('voiceStatus');
            const visualizer = document.getElementById('visualizer');
            const recordingIndicator = document.getElementById('recordingIndicator');

            switch (state) {
                case 'listening':
                    voiceButton.style.display = 'none';
                    stopButton.style.display = 'inline-block';
                    status.textContent = 'Listening... Speak your response now';
                    status.className = 'voice-status listening';
                    if (visualizer) visualizer.style.display = 'block';
                    if (recordingIndicator) recordingIndicator.style.display = 'block';
                    break;
                case 'stopped':
                    voiceButton.style.display = 'inline-block';
                    stopButton.style.display = 'none';
                    status.textContent = 'Ready to speak your response';
                    status.className = 'voice-status ready';
                    if (visualizer) visualizer.style.display = 'none';
                    if (recordingIndicator) recordingIndicator.style.display = 'none';
                    break;
                case 'error':
                    voiceButton.style.display = 'inline-block';
                    stopButton.style.display = 'none';
                    status.textContent = 'Voice input error - try again';
                    status.className = 'voice-status error';
                    if (visualizer) visualizer.style.display = 'none';
                    if (recordingIndicator) recordingIndicator.style.display = 'none';
                    break;
            }
        }

        // Update answer text when voice recognition returns results
        if (typeof voiceRecognition !== 'undefined') {
            voiceRecognition.onResult = function (transcript) {
                console.log('üí¨ Voice recognition result:', transcript);
                const answerTextarea = document.getElementById('answer');
                if (answerTextarea) {
                    answerTextarea.value = transcript;
                }
                const voicePreview = document.getElementById('voicePreview');
                if (voicePreview) {
                    voicePreview.textContent = transcript;
                }
            };
        }

        // Form submission handler
        document.getElementById('answerForm').addEventListener('submit', function (e) {
            e.preventDefault();
            console.log('üì§ Form submitted');

            const answer = document.getElementById('answer').value;
            if (!answer.trim()) {
                document.getElementById('answer').value = '[No response provided]';
            }

            // Stop all timers
            interviewTimer.stopAllTimers();

            // Stop voice recognition if available
            if (typeof voiceRecognition !== 'undefined') {
                voiceRecognition.stopListening();
            }

            // Stop TTS if available
            textToSpeech.stop();

            // Stop voice recognition and its media stream
            if (typeof voiceRecognition !== 'undefined') {
                voiceRecognition.stopListening();
            }

            // Show loading
            document.getElementById('loadingOverlay').style.display = 'flex';

            // Submit answer
            const formData = new FormData(this);

            fetch('/submit_answer', {
                method: 'POST',
                body: formData
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok: ' + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('‚úÖ Submit answer response:', data);
                    document.getElementById('loadingOverlay').style.display = 'none';

                    // Hide feedback section during interview (only show on completion)
                    if (data.completed) {
                        // Show feedback only when interview is completed
                        document.getElementById('feedbackContent').innerHTML = `
                    <p><strong>Rishi Assessment:</strong> ${data.score}/10</p>
                    <p><strong>Feedback:</strong> ${data.feedback}</p>
                    <p style="margin-top: 1rem; font-weight: bold; color: #667eea;">üéâ Interview Completed! Redirecting to results...</p>
                `;

                        document.getElementById('feedbackSection').style.display = 'block';
                        document.getElementById('feedbackSection').scrollIntoView({ behavior: 'smooth' });

                        document.getElementById('nextQuestionBtn').textContent = 'View Results Now';
                        document.getElementById('nextQuestionBtn').onclick = function () {
                            interviewTimer.stopEverything();
                            window.location.href = '/results';
                        };
                        document.querySelector('.auto-next-countdown').style.display = 'none';

                        // Stop all media when interview is completed
                        interviewTimer.stopAllMedia();

                        // Auto-redirect after 2 seconds
                        setTimeout(() => {
                            interviewTimer.stopEverything();
                            window.location.href = '/results';
                        }, 2000);
                    } else {
                        // During interview: hide feedback, auto-advance to next question
                        document.getElementById('feedbackSection').style.display = 'none';
                        // Load next question without reloading the page (keeps camera/mic stable)
                        setTimeout(() => {
                            interviewTimer.loadNextQuestion();
                        }, 300);
                    }
                })
                .catch(error => {
                    console.error('‚ùå Error submitting answer:', error);
                    document.getElementById('loadingOverlay').style.display = 'none';
                    alert('Error submitting response. Please try again.');
                });
        });

        // Skip question
        document.getElementById('skipButton').addEventListener('click', function () {
            if (confirm('Are you sure you want to skip this question?')) {
                document.getElementById('answer').value = '[Skipped]';
                document.getElementById('answerForm').dispatchEvent(new Event('submit'));
            }
        });

        // Clean up when page is unloaded (user navigates away or closes tab)
        window.addEventListener('beforeunload', function () {
            console.log('üö™ Page unloading - cleaning up media streams...');
            interviewTimer.stopEverything();
        });

        // Clean up when page becomes hidden (tab switched, minimized, etc.)
        document.addEventListener('visibilitychange', function () {
            if (document.hidden) {
                console.log('üëÅÔ∏è Page hidden - stopping media...');
                // Optionally stop media when page is hidden
                // interviewTimer.stopAllMedia();
            }
        });

        // Handle page exit gracefully
        window.addEventListener('pagehide', function () {
            console.log('üëã Page hiding - cleaning up...');
            interviewTimer.stopEverything();
        });

        // Enhanced CSS application on page load
        window.addEventListener('load', function () {
            // Apply CSS fixes after all resources are loaded
            setTimeout(() => {
                applyCSSFixes();
                console.log('‚úÖ CSS fixes applied after full page load');
            }, 100);
        });

        // Re-apply styles when DOM changes (for dynamic content)
        const observer = new MutationObserver(function (mutations) {
            let shouldApplyFixes = false;

            mutations.forEach(function (mutation) {
                if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                    // New elements added - check if they need styling
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType === 1) { // Element node
                            const classes = node.className || '';
                            if (classes.includes('question') ||
                                classes.includes('answer') ||
                                classes.includes('timer') ||
                                classes.includes('btn')) {
                                shouldApplyFixes = true;
                            }
                        }
                    });
                }

                if (mutation.type === 'attributes' &&
                    (mutation.attributeName === 'class' || mutation.attributeName === 'style')) {
                    shouldApplyFixes = true;
                }
            });

            if (shouldApplyFixes) {
                // Debounce CSS fixes to avoid excessive calls
                clearTimeout(window.cssFixTimeout);
                window.cssFixTimeout = setTimeout(() => {
                    applyCSSFixes();
                }, 50);
            }
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['class', 'style']
        });

        // Apply CSS fixes when page becomes visible (handles back/forward navigation)
        document.addEventListener('visibilitychange', function () {
            if (!document.hidden) {
                setTimeout(() => {
                    applyCSSFixes();
                    console.log('‚úÖ CSS fixes applied after visibility change');
                }, 100);
            }
        });

        console.log('üéØ All event listeners attached - TTS is ready!');
    });

    // Manual start button for debugging
    function manualStartInterview() {
        console.log('üîò Manual start button clicked');
        showRobotForTesting();
    }
</script>

<style>
    .permission-warning {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 12px;
        padding: 2rem;
        margin-bottom: 2rem;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    }

    .permission-warning .warning-content {
        text-align: center;
    }

    .permission-warning h4 {
        font-size: 1.5rem;
        margin-bottom: 1rem;
        color: white;
    }

    .permission-steps {
        background: rgba(255, 255, 255, 0.1);
        padding: 1rem;
        border-radius: 8px;
        margin: 1.5rem 0;
        text-align: left;
    }

    .permission-steps ol {
        margin: 0.5rem 0;
        padding-left: 1.5rem;
    }

    .permission-steps li {
        margin: 0.5rem 0;
    }

    .btn-large {
        padding: 12px 24px;
        font-size: 1.1rem;
        font-weight: bold;
    }

    .camera-placeholder {
        background: #f8f9fa;
        border: 3px dashed #dee2e6;
        border-radius: 12px;
        height: 400px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 1rem 0;
    }

    .placeholder-content {
        text-align: center;
    }

    .placeholder-icon {
        font-size: 4rem;
        margin-bottom: 1rem;
        opacity: 0.7;
    }

    .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }

    /* Chatbot Button Styles */
    .chatbot-button-container {
        text-align: center;
        margin: 2rem 0;
        animation: fadeIn 0.5s ease-out;
    }

    .chatbot-btn {
        padding: 20px 40px;
        font-size: 1.3rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        transition: all 0.3s ease;
        animation: pulse 2s infinite;
    }

    .chatbot-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6);
    }

    .chatbot-btn:active {
        transform: translateY(-1px);
    }

    /* Hide behavioral questions in interview mode */
    body.interview-mode .question-card[style*="display: none"] {
        display: none !important;
    }

    /* Answer Section Header */
    .answer-section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid #e0e0e0;
    }

    .answer-section-header h4 {
        margin: 0;
        font-size: 1.5rem;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    /* Ensure answer section is hidden by default in interview mode */
    body.interview-mode .answer-section {
        display: none !important;
    }

    body.interview-mode .answer-section[style*="display: block"] {
        display: block !important;
    }

    /* Physical Analysis Animation Styles */
    @keyframes slideInLeft {
        from {
            opacity: 0;
            transform: translateX(-50px);
        }

        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    @keyframes pulse {

        0%,
        100% {
            transform: scale(1);
            opacity: 1;
        }

        50% {
            transform: scale(1.05);
            opacity: 0.9;
        }
    }

    .animate-in {
        animation: slideInLeft 0.5s ease-out;
    }

    .analysis-item {
        margin: 8px 0;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .analysis-label {
        flex: 0 0 100px;
        font-size: 11px;
        opacity: 0.9;
    }

    .analysis-value {
        flex: 0 0 50px;
        font-weight: 700;
        text-align: right;
        transition: all 0.3s ease;
    }

    .analysis-bar {
        flex: 1;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        overflow: hidden;
        position: relative;
    }

    .analysis-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
        border-radius: 10px;
        transition: width 0.5s ease-out;
        box-shadow: 0 2px 8px rgba(79, 172, 254, 0.5);
    }

    .score-high {
        color: #4facfe;
        animation: pulse 2s infinite;
    }

    .score-medium {
        color: #f39c12;
    }

    .score-low {
        color: #e74c3c;
    }

    /* AI Avatar Pulsing Animation */
    .ai-avatar {
        position: relative;
        width: 60px;
        height: 60px;
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 10px auto 0;
    }

    .ai-avatar .core {
        width: 30px;
        height: 30px;
        background: #00d2ff;
        border-radius: 50%;
        box-shadow: 0 0 20px #00d2ff, 0 0 40px #00d2ff, 0 0 60px #00d2ff;
        z-index: 2;
        animation: corePulse 2s infinite;
    }

    .ai-avatar .pulse-ring {
        position: absolute;
        width: 30px;
        height: 30px;
        background: transparent;
        border: 2px solid #00d2ff;
        border-radius: 50%;
        animation: pulseRing 2s infinite;
    }

    @keyframes corePulse {

        0%,
        100% {
            transform: scale(1);
            box-shadow: 0 0 20px #00d2ff, 0 0 40px #00d2ff, 0 0 60px #00d2ff;
        }

        50% {
            transform: scale(1.1);
            box-shadow: 0 0 30px #00d2ff, 0 0 60px #00d2ff, 0 0 90px #00d2ff;
        }
    }

    @keyframes pulseRing {
        0% {
            transform: scale(1);
            opacity: 1;
            border-color: #00d2ff;
        }

        50% {
            transform: scale(1.5);
            opacity: 0.7;
            border-color: #00aaff;
        }

        100% {
            transform: scale(2.5);
            opacity: 0;
            border-color: #0088ff;
        }
    }

    /* Robot Screen Content Layout */
    .screen-content {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        padding: 10px;
    }

    .screen-text {
        font-size: 14px;
        font-weight: bold;
        color: #00d2ff;
        margin-bottom: 5px;
        text-shadow: 0 0 10px #00d2ff;
    }

    .screen-pulse {
        width: 20px;
        height: 2px;
        background: #00d2ff;
        margin: 5px auto;
        border-radius: 1px;
        animation: screenPulse 1.5s infinite;
    }

    @keyframes screenPulse {

        0%,
        100% {
            opacity: 0.3;
        }

        50% {
            opacity: 1;
        }
    }

    /* OTP Modal Styles */
    .otp-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fadeIn 0.3s ease-out;
    }

    .otp-modal-content {
        background: white;
        padding: 3rem;
        border-radius: 25px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        max-width: 500px;
        width: 90%;
        text-align: center;
        animation: slideUp 0.4s ease-out;
    }

    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(30px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .otp-modal-content h3 {
        font-size: 2rem;
        margin-bottom: 1rem;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .otp-modal-content p {
        color: #7f8c8d;
        margin-bottom: 2rem;
        font-size: 1.1rem;
    }

    .otp-display {
        background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
        padding: 1.5rem;
        border-radius: 15px;
        margin-bottom: 1.5rem;
    }

    .otp-input-group {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
        align-items: center;
    }

    .otp-input {
        flex: 1;
        padding: 15px 20px;
        font-size: 1.5rem;
        text-align: center;
        letter-spacing: 0.5rem;
        border: 3px solid #e0e0e0;
        border-radius: 15px;
        font-weight: bold;
        transition: all 0.3s ease;
    }

    .otp-input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.15);
        transform: scale(1.02);
    }

    .otp-error {
        color: var(--danger);
        background: rgba(231, 76, 60, 0.1);
        padding: 1rem;
        border-radius: 10px;
        margin-top: 1rem;
        font-weight: 600;
    }

    .otp-help {
        margin-top: 1.5rem;
        padding-top: 1.5rem;
        border-top: 2px solid #e0e0e0;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }
</style>
{% endblock %}